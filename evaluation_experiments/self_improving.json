{
    "zero-shot": {
        "0": {
            "formalization": "theory Factorial_Divisibility\n  imports Main \"~~/src/HOL/Number_Theory/Divisibility\"\nbegin\n\nlemma least_positive_integer:\n  assumes \"n > 0\"\n  shows \"80325 divides (fact n) \\<longleftrightarrow> n \\<ge> 17\"\n  using assms\n  by (simp add: factorial_divides_iff)\n\nlemma least_n:\n  shows \"80325 divides (fact 17) \\<and> (\\<forall>n < 17. \\<not> 80325 divides (fact n))\"\n  by (simp add: factorial_divides_iff)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It establishes the condition for divisibility of \\( n! \\) by \\( 80325 \\) and identifies the least positive integer \\( n \\) that satisfies this condition, which is shown to be \\( 17 \\). The first lemma asserts that \\( 80325 \\) divides \\( n! \\) if and only if \\( n \\) is at least \\( 17 \\), while the second lemma confirms that \\( 80325 \\) divides \\( 17! \\) and that no smaller \\( n \\) satisfies this divisibility. Thus, all aspects of the original statement are addressed in the formalization. \n"
        },
        "1": {
            "formalization": "theory Divisibility\n  imports Main\nbegin\n\nlemma div_11: \"∀n::nat. 11 ∣ (10^n - (-1)^n)\"\n  by (induction n) (auto simp add: mod_mult_right mod_add)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner lexical error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 6\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL accurately captures the mathematical statement that for any natural number \\( n \\), \\( 11 \\) divides \\( 10^n - (-1)^n \\). The use of the universal quantifier \\( ∀n::nat \\) ensures that the statement applies to all natural numbers, and the expression \\( 11 ∣ (10^n - (-1)^n) \\) directly corresponds to the divisibility condition stated in the natural language. The proof by induction and the use of simplification tactics further support the correctness of the formalization, confirming that all relevant mathematical concepts are included.\n"
        },
        "2": {
            "formalization": "theory Congruence\n  imports Main\nbegin\n\nlemma congruence_solution:\n  assumes \"3 * n ≡ 2 (mod 11)\"\n  shows \"n ≡ 8 (mod 11)\"\nproof -\n  have \"3 * 8 mod 11 = 24 mod 11\"\n    by simp\n  also have \"... = 2\"\n    by simp\n  finally show ?thesis\n    by (simp add: assms)\nqed\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 8\nError message: Bad context for command \"proof\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It correctly states the congruence \\(3n \\equiv 2 \\pmod{11}\\) and provides a proof that shows \\(n \\equiv 8 \\pmod{11}\\) is a solution. The proof verifies the calculation \\(3 \\cdot 8 \\mod 11 = 2\\), which confirms that 8 is indeed the correct residue modulo 11. Thus, the formalization meets the requirement of involving all mathematical concepts present in the original statement.\n"
        },
        "3": {
            "formalization": "theory Euler_Prime\n  imports Main\nbegin\n\nfun p :: \"nat ⇒ nat\" where\n  \"p n = n^2 - n + 41\"\n\nlemma common_factor:\n  assumes \"n > 0\"\n  shows \"gcd (p n) (p (n + 1)) > 1 ⟷ n = 41\"\nproof -\n  have \"p (n + 1) = (n + 1)^2 - (n + 1) + 41\"\n    by (simp add: p.simps)\n  then show ?thesis\n    by (simp add: gcd_def)\nqed\n\nend\n",
            "error_details": "Identified error on line: 15\nError message: Undefined fact: \"gcd_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It defines the polynomial \\( p(n) = n^2 - n + 41 \\) and establishes a lemma that investigates the common factors of \\( p(n) \\) and \\( p(n+1) \\). The lemma specifically addresses the condition of finding the smallest positive integer \\( n \\) such that \\( p(n) \\) and \\( p(n+1) \\) share a common factor greater than 1, and it concludes that this occurs when \\( n = 41 \\). Thus, all key elements of the original statement are represented in the formal code.\n"
        },
        "4": {
            "formalization": "theory MinValue\n  imports \"HOL.Real\"\nbegin\n\nlemma min_value:\n  fixes x :: real\n  shows \"x^2 - 14*x + 3 = (x - 7)^2 - 49 + 3\"\n  by (simp add: algebra_simps)\n\nlemma minimum_at_7:\n  shows \"min x. (x^2 - 14*x + 3) = 7\"\n  using min_value by auto\n\nend\n",
            "error_details": "Identified error on line: 8\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. x\\<^sup>2 + 49 = x * 14 + (x - 7)\\<^sup>2\n\nIdentified error on line: 10\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 12\nError message: Bad context for command \"using\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical concepts present in the natural language statement. Specifically, the statement asks for the value of \\( x \\) that minimizes the expression \\( x^2 - 14x + 3 \\) and explicitly states that this value is 7. However, the formal code does not demonstrate that 7 is indeed the minimum value of the expression; it only shows a transformation of the quadratic expression and states that the minimum occurs at \\( x = 7 \\) without proving that this is the minimum value. Additionally, the formalization lacks a clear demonstration or proof that the minimum value of the quadratic expression is indeed 3 (the value of the expression at \\( x = 7 \\)). Therefore, it does not involve all the necessary mathematical concepts from the original statement.\n"
        },
        "5": {
            "formalization": "theory Trigonometric_Identity\n  imports Complex_Main\nbegin\n\nlemma sec_tan_csc_cot:\n  assumes \"sec x + tan x = 22 / 7\"\n  shows \"∃m n. csc x + cot x = m / n ∧ coprime m n\"\n  using assms\n  by (metis)\n\nend\n",
            "error_details": "Identified error on line: 9\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  sec x + tan x = 22 / 7\ngoal (1 subgoal):\n 1. \\<exists>m n. csc x + cot x = m / n \\<and> coprime m n\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It states the assumption that \\(\\sec x + \\tan x = \\frac{22}{7}\\) and shows that there exist integers \\(m\\) and \\(n\\) such that \\(\\csc x + \\cot x = \\frac{m}{n}\\) with \\(m\\) and \\(n\\) being coprime. The use of existential quantification and the coprimality condition aligns with the requirements of the original statement, thus ensuring that all mathematical concepts are represented in the formalization.\n"
        },
        "6": {
            "formalization": "theory Integer_Values\n  imports Real\nbegin\n\nlemma integer_values: \"card {x. |x| < 3 * pi} = 19\"\n  by (simp add: card_of_interval)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization correctly captures the mathematical statement by defining a set of integer values \\( x \\) that satisfy the condition \\( |x| < 3\\pi \\). The use of the cardinality function `card` to count the number of elements in the set aligns with the question of how many integer values satisfy the inequality. The conclusion that this cardinality equals 19 is also consistent with the natural language statement, which asserts that the answer is (D) 19. Therefore, all mathematical concepts from the natural language statement are involved in the formalization.\n"
        },
        "7": {
            "formalization": "theory SumOfRoots\n  imports Main\nbegin\n\nlemma sum_of_roots:\n  assumes \"(x + 3)^2 = 121\"\n  shows \"x + 3 = 11 ∨ x + 3 = -11 ⟹ x = 8 ∨ x = -14 ⟹ x + x = -6\"\n  using assms by auto\n\nend\n",
            "error_details": "Identified error on line: 8\nError message: Failed to finish proof\\<^here>:\ngoal (4 subgoals):\n 1. 11\\<^sup>2 = 121 \\<Longrightarrow> x = 8 \\<Longrightarrow> 16 = - 6\n 2. 11\\<^sup>2 = 121 \\<Longrightarrow> - 14 + 3 = 11 \\<Longrightarrow> x = - 14 \\<Longrightarrow> - 14 + - 14 = - 6\n 3. 11\\<^sup>2 = 121 \\<Longrightarrow> 11 = - 11 \\<Longrightarrow> x = 8 \\<Longrightarrow> 16 = - 6\n 4. (- 11)\\<^sup>2 = 121 \\<Longrightarrow> - 14 + 3 = - 11 \\<Longrightarrow> x = - 14 \\<Longrightarrow> - 14 + - 14 = - 6\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately capture all the mathematical concepts present in the natural language statement. Specifically, while it correctly sets up the equation and derives the values of \\(x\\), it fails to explicitly state the sum of the two values of \\(x\\) before concluding that it is -6. The natural language statement asks for the sum of the two values of \\(x\\) (which are 8 and -14), but the formalization jumps directly to the conclusion without clearly showing the intermediate step of calculating the sum of these values. Therefore, it does not fully meet the requirement of involving all mathematical concepts from the original statement.\n"
        },
        "8": {
            "formalization": "theory Expand_Product\n  imports Main\nbegin\n\nlemma expand_product: \"(x + 1)^2 * x = x^3 + 2 * x^2 + x\"\n  by (simp add: power2_eq_square)\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. (x + 1)\\<^sup>2 * x = x ^ 3 + 2 * x\\<^sup>2 + x\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code accurately captures all the mathematical concepts presented in the natural language statement. It expands the product \\((x+1)^2 \\cdot x\\) and demonstrates that it equals \\(x^3 + 2x^2 + x\\). The lemma states the equality directly, and the use of the simplification tactic (`simp`) with the appropriate addition of the `power2_eq_square` lemma ensures that the expansion is correctly derived. Thus, all elements of the original statement are represented in the formalization.\n"
        },
        "9": {
            "formalization": "theory Prime_Divides\n  imports \"HOL.Number_Theory.Prime\"\nbegin\n\nlemma prime_divides_a_p_minus_a:\n  fixes p :: nat and a :: nat\n  assumes \"prime p\" \"0 < a\"\n  shows \"p dvd (a^p - a)\"\n  using assms\n  by (metis (no_types, lifting) dvd_def prime_dvd_pow)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines a prime number \\( p \\) and a positive integer \\( a \\), and it correctly states the lemma that \\( p \\) divides \\( a^p - a \\). The assumptions include the primality of \\( p \\) and the positivity of \\( a \\), which are essential to the statement. The use of the `dvd` (divides) function and the proof method employed (using `metis` with the `prime_dvd_pow` theorem) appropriately reflects the mathematical reasoning required to show the divisibility condition. Thus, the formalization meets the aspect of involving all mathematical concepts from the natural language statement.\n"
        },
        "10": {
            "formalization": "theory Units_Digit_Sum_Squares\n  imports Main\nbegin\n\nlemma units_digit_sum_squares:\n  shows \"(\\<Sum>n::nat. (n + 1)^2) mod 10 = 5\"\n  unfolding sum.cong\n  by (simp add: sum_of_squares)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 7\nError message: Bad context for command \"unfolding\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It correctly identifies the task of finding the units digit of the sum of the squares of the first nine positive integers by using the summation notation and the modulus operation to determine the units digit. The lemma states that the sum of the squares of the integers from 1 to 9, when taken modulo 10, equals 5, which directly corresponds to the claim made in the natural language statement. Thus, all relevant mathematical concepts are included in the formalization.\n"
        },
        "11": {
            "formalization": "theory Distinct_Digits\n  imports Main\nbegin\n\n  definition A :: nat where \"A = 1\"\n  definition B :: nat where \"B = 2\"\n  definition C :: nat where \"C = 5\"\n\n  lemma distinct_digits: \"A ≠ B ∧ A ≠ C ∧ B ≠ C\"\n    by (simp add: A_def B_def C_def)\n\n  lemma equations: \"A + B = C ∧ (10 * A + A) - B = 2 * C ∧ C * B = (10 * A + A) + A\"\n    by (simp add: A_def B_def C_def)\n\n  lemma sum: \"A + B + C = 8\"\n    by (simp add: A_def B_def C_def)\n\nend\n",
            "error_details": "Identified error on line: 13\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. False\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not involve all mathematical concepts present in the natural language statement. While it defines three distinct digits A, B, and C and provides some equations, it does not explicitly state that A, B, and C must be distinct digits from 1 to 9. The definitions of A, B, and C are fixed to specific values (1, 2, and 5), which does not allow for the generality implied in the natural language statement. Additionally, the formalization lacks a mechanism to ensure that A, B, and C are indeed distinct digits from the specified range, which is a crucial part of the original problem. Therefore, it fails to capture the full scope of the mathematical concepts involved. \n"
        },
        "12": {
            "formalization": "theory Odd_Integers_Product\n  imports Main\nbegin\n\nlemma product_of_odd_integers_less_than_10000:\n  \"(\\<Prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\n  by (simp add: factorial_def)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 7\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code correctly captures the mathematical concept of the product of all positive odd integers less than 10000. It uses the notation for the product of integers in the form of \\(2*i + 1\\), which generates all odd integers up to 9999. The result is expressed as \\(\\frac{10000!}{2^{5000} \\cdot 5000!}\\), which matches option (D) from the original statement. Therefore, all relevant mathematical concepts from the natural language statement are included in the formalization.\n"
        },
        "13": {
            "formalization": "theory SolutionSet\n  imports Real\nbegin\n\nlemma solution_set_integer_count:\n  shows \"card {x :: int. |x - 2| ≤ 5.6} = 11\"\n  by (simp add: abs_le_iff)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It defines the solution set for the inequality \\( |x-2| \\leq 5.6 \\) and correctly asserts that the cardinality of the set of integers satisfying this condition is 11. The use of the `card` function to count the integers in the set and the application of `abs_le_iff` to simplify the expression confirms that the formalization accurately reflects the original statement's requirements.\n"
        },
        "14": {
            "formalization": "theory Triangle_Inequality\n  imports \"HOL.Real\"\nbegin\n\nlemma triangle_inequality:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ≥ 0\"\nproof -\n  (* Proof goes here *)\nqed\n\nend\n",
            "error_details": "Identified error on line: 11\nError message: Failed to finish proof:\ngoal (1 subgoal):\n 1. 0 \\<le> a\\<^sup>2 * b * (a - b) + b\\<^sup>2 * c * (b - c) + c\\<^sup>2 * a * (c - a)\n\nIdentified error on line: 13\nError message: Bad context for command \"end\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the requirement to determine when equality occurs, which is explicitly stated in the natural language statement. While it correctly formalizes the inequality involving the sides of the triangle, it lacks any mention or exploration of the conditions under which equality holds. Therefore, it does not involve all mathematical concepts present in the original statement.\n"
        },
        "15": {
            "formalization": "theory Example\n  imports Main\nbegin\n\nlemma example:\n  assumes \"3 * a + b + c = -3\"\n    and \"a + 3 * b + c = 9\"\n    and \"a + b + 3 * c = 19\"\n  shows \"a * b * c = -56\"\nproof -\n  obtain a b c where \"3 * a + b + c = -3\" \"a + 3 * b + c = 9\" \"a + b + 3 * c = 19\"\n    using assms by auto\n  then have \"a = 1\" \"b = -4\" \"c = 3\" by (simp_all add: ...)\n  then show ?thesis by simp\nqed\n\nend\n",
            "error_details": "Identified error on line: 12\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n    3 * a + b + c = - 3\n    a + 3 * b + c = 9\n    a + b + 3 * c = 19\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        3 * a + b + c = - 3 \\<Longrightarrow>\n        a + 3 * b + c = 9 \\<Longrightarrow> a + b + 3 * c = 19 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis\n\nIdentified error on line: 13\nError message: Outer syntax error\\<^here>: keyword \")\" expected,\nbut end-of-input\\<^here> was found\n\nIdentified error on line: 13\nError message: Failed to apply initial proof method:\nusing this:\n    3 * a + b + c = - 3\n    a + 3 * b + c = 9\n    a + b + 3 * c = 19\ngoal (1 subgoal):\n 1. a = 1 &&& b = - 4 &&& c = 3\n\nIdentified error on line: 13\nError message: Outer syntax error\\<^here>: command expected,\nbut keyword )\\<^here> was found\n\nIdentified error on line: 14\nError message: Illegal application of proof command in \"prove\" mode\n\nIdentified error on line: 14\nError message: Unbound schematic variable: ?thesis\n\nIdentified error on line: 14\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n    3 * a + b + c = - 3\n    a + 3 * b + c = 9\n    a + b + 3 * c = 19\ngoal (1 subgoal):\n 1. a = 1 &&& b = - 4 &&& c = 3\n\nIdentified error on line: 15\nError message: Failed to finish proof:\ngoal (1 subgoal):\n 1. a * b * c = - 56\n\nIdentified error on line: 17\nError message: Bad context for command \"end\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It correctly sets up the assumptions based on the given equations involving the variables \\(a\\), \\(b\\), and \\(c\\). The proof proceeds to derive specific values for \\(a\\), \\(b\\), and \\(c\\) that satisfy the equations, and ultimately shows that the product \\(abc\\) equals \\(-56\\). Therefore, all aspects of the original statement are addressed in the formalization.\n"
        },
        "16": {
            "formalization": "theory Sequence_Parity\n  imports Main\nbegin\n\nfun D :: \"nat ⇒ nat\" where\n  \"D 0 = 0\" |\n  \"D 1 = 0\" |\n  \"D 2 = 1\" |\n  \"D n = D (n - 1) + D (n - 3) ∀ n ≥ 3\"\n\ndefinition parity :: \"nat ⇒ bool\" where\n  \"parity n ≡ D n mod 2 = 0\"\n\nlemma parity_triple: \"parity 2021 = False ∧ parity 2022 = True ∧ parity 2023 = False\"\n  by (simp add: parity_def)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 11\nError message: Extra variables on rhs: \"D\"\nThe error(s) above occurred in definition:\n\"parity n \\<equiv> D n mod 2 = 0\"\n\nIdentified error on line: 15\nError message: Undefined fact: \"parity_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It defines the sequence \\(D_n\\) correctly with the base cases and the recursive relation for \\(n \\geq 3\\). Additionally, it introduces a definition for parity that checks if a number is even or odd. The lemma `parity_triple` correctly asserts the parities of \\(D_{2021}\\), \\(D_{2022}\\), and \\(D_{2023}\\) as required by the statement. Thus, all necessary components of the original statement are addressed in the formalization.\n"
        },
        "17": {
            "formalization": "theory Inverse_Function\n  imports Main\nbegin\n\n  definition h :: \"nat ⇒ nat\" where \"h x = f_inv x\"\n\n  assumption h_2: \"h 2 = 10\"\n  assumption h_10: \"h 10 = 1\"\n  assumption h_1: \"h 1 = 2\"\n\n  lemma f_f_10: \"f (f 10) = 1\"\n  proof -\n    have \"h (f 10) = 2\" using h_1 by (simp add: h_def)\n    then have \"f (h (f 10)) = f 2\" by (simp add: f_inv_def)\n    then show ?thesis using h_2 by (simp add: h_def)\n  qed\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Outer syntax error\\<^here>: command expected,\nbut identifier assumption\\<^here> was found\n\nIdentified error on line: 13\nError message: Undefined fact: \"h_1\"\\<^here>\n\nIdentified error on line: 13\nError message: Undefined fact: \"h_def\"\\<^here>\n\nIdentified error on line: 14\nError message: Type unification failed\n\nType error in application: incompatible operand type\n\nOperator:  f :: 'a \\<Rightarrow> 'a\nOperand:   h (f 10) :: 'b\n\n\nIdentified error on line: 14\nError message: Illegal application of proof command in \"chain\" mode\n\nIdentified error on line: 15\nError message: Illegal application of proof command in \"chain\" mode\n\nIdentified error on line: 15\nError message: Undefined fact: \"h_2\"\\<^here>\n\nIdentified error on line: 15\nError message: Undefined fact: \"h_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It defines the function \\( h \\) as the inverse of \\( f \\) and includes the necessary assumptions about the values of \\( h \\) at specific points (i.e., \\( h(2)=10 \\), \\( h(10)=1 \\), and \\( h(1)=2 \\)). The lemma \\( f(f(10)) = 1 \\) is correctly stated and proved using these assumptions, demonstrating the relationship between \\( h \\) and \\( f \\) as required. Thus, all relevant concepts from the natural language statement are addressed in the formalization. \n"
        },
        "18": {
            "formalization": "theory Perfect_Squares_Divisors\n  imports Main \"HOL/Number_Theory/Divisors\"\nbegin\n\ndefinition factorial_product :: \"nat\" where\n  \"factorial_product = (1! * 2! * 3! * 4! * 5! * 6! * 7! * 8! * 9!)\"\n\nlemma perfect_squares_divisors_count:\n  \"count_perfect_squares_divisors factorial_product = 672\"\n  by (simp add: factorial_product_def)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the necessary mathematical concepts from the natural language statement. It defines the product of the factorials from 1 to 9, which is essential for determining the divisors of this product. The lemma specifically addresses the count of perfect square divisors of this product, asserting that there are 672 such divisors, which corresponds to the answer choice (B) in the original statement. Thus, the formalization effectively incorporates all relevant concepts: the factorial product, the notion of divisors, and the specific focus on perfect squares.\n"
        },
        "19": {
            "formalization": "theory IMO_2001\n  imports Main\nbegin\n\ndefinition I :: nat where \"I = 1\"\ndefinition M :: nat where \"M = 7\"\ndefinition O :: nat where \"O = 287\"\n\nlemma distinct_positive_integers: \"I ≠ M ∧ I ≠ O ∧ M ≠ O\"\n  by (simp add: I_def M_def O_def)\n\nlemma product: \"I * M * O = 2001\"\n  by (simp add: I_def M_def O_def)\n\nlemma sum: \"I + M + O = 1 + 7 + 287\"\n  by (simp add: I_def M_def O_def)\n\nlemma largest_sum: \"I + M + O = 295\"\n  by (simp add: sum)\n\nend\n",
            "error_details": "Identified error on line: 7\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 9\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 10\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\nIdentified error on line: 12\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 13\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\nIdentified error on line: 15\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 16\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\nIdentified error on line: 18\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 19\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately represent all the mathematical concepts in the natural language statement. Specifically, while the definitions of I, M, and O as distinct positive integers are provided, the formal code incorrectly computes the sum as 295 instead of finding the largest possible value of the sum I + M + O that satisfies the product condition. Additionally, the formalization does not explore other combinations of distinct positive integers that could yield a larger sum, which is essential to answering the question posed in the natural language statement. Therefore, it fails to encompass the full scope of the problem.\n"
        },
        "20": {
            "formalization": "theory Smallest_X\n  imports Main\nbegin\n\ndefinition X :: nat where\n  \"X = (let m = 3 * (n::nat) + 2 in m + (if m mod 10 = (5 + 4) mod 10 then 0 else 1))\"\n\nlemma smallest_X: \"X = 14\"\n  unfolding X_def\n  by (metis mod_eq_0_iff_dvd)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture all the mathematical concepts present in the natural language statement. Specifically, while it defines \\( X \\) as being 2 more than a multiple of 3, it does not explicitly ensure that \\( X \\) is a positive integer. Additionally, the condition regarding the units digit of \\( X \\) being the same as that of a number that is 4 more than a multiple of 5 is not correctly represented in the definition of \\( X \\). The code only checks if the units digit of \\( m \\) (which is \\( 3n + 2 \\)) is equal to the units digit of \\( 9 \\) (which is \\( 4 \\mod 10 \\)), but it does not incorporate the requirement that \\( X \\) must satisfy both conditions simultaneously. Therefore, the formalization is incomplete and does not encompass all aspects of the original statement. \n"
        },
        "21": {
            "formalization": "theory Modulo4Remainder\n  imports Main\nbegin\n\nlemma modulo_4_remainder_sum: \"((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12) mod 4) = 2\"\n  by simp\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. 78 mod 4 = 2\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL accurately captures the mathematical concepts presented in the natural language statement. It correctly computes the sum of the integers from 1 to 12 and applies the modulo operation with 4 to determine the remainder. The lemma explicitly states that this remainder is equal to 2, which aligns with the conclusion of the original statement. Therefore, all relevant mathematical concepts are included in the formalization.\n"
        },
        "22": {
            "formalization": "theory Real_Numbers\n  imports \"HOL/Analysis/Real\"\nbegin\n\nlemma real_numbers_bounds:\n  fixes a b c :: real\n  assumes \"a ≤ b\" \"b ≤ c\" \"a + b + c = 2\" \"a * b + b * c + c * a = 1\"\n  shows \"0 ≤ a ∧ a ≤ (1/3) ∧ (1/3) ≤ b ∧ b ≤ 1 ∧ 1 ≤ c ∧ c ≤ (4/3)\"\n  \nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It correctly defines the variables \\(a\\), \\(b\\), and \\(c\\) as real numbers and includes the necessary assumptions regarding their relationships and sums. The conclusion of the lemma specifies the bounds for \\(a\\), \\(b\\), and \\(c\\) as required, ensuring that all conditions from the natural language statement are addressed. Thus, the formalization meets the aspect of involving all mathematical concepts.\n"
        },
        "23": {
            "formalization": "theory Percentage_Equation\n  imports Main\nbegin\n\nlemma five_plus_500_percent_of_10_equals_110_percent_of_x:\n  assumes \"x = 50\"\n  shows \"5 + (500 / 100) * 10 = (110 / 100) * x\"\n  by (simp add: assms)\n\nend\n",
            "error_details": "Identified error on line: 8\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. 5 + 500 / 100 * 10 = 110 / 100 * 50\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It correctly represents the equation \"Five plus $500\\%$ of $10$\" as \"5 + (500 / 100) * 10\" and \"110\\% of what number\" as \"(110 / 100) * x\". The assumption \"x = 50\" is also included, which is necessary to show that the equation holds true for the specified value. Therefore, the formal code encompasses all the elements of the original statement.\n"
        },
        "24": {
            "formalization": "theory Remainder\n  imports \"HOL.Num\"\nbegin\n\nlemma remainder_5_power_999999_mod_7: \"5 ^ 999999 mod 7 = 6\"\n  apply (simp add: mod_mult_eq)\n  apply (subst (2) mod_eq_0_iff)\n  apply (simp add: mod_add_eq)\n  apply (simp add: mod_mult_eq)\n  apply (simp add: mod_eq_0_iff)\n  done\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner lexical error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 6\nError message: Bad context for command \"apply\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It correctly states the lemma regarding the remainder of \\(5^{999999}\\) when divided by \\(7\\) and asserts that this remainder is \\(6\\). The use of the `mod` operator and the proof steps involving simplifications and substitutions demonstrate that the formalization addresses the core mathematical operation of finding a remainder, as requested in the natural language statement. Therefore, it meets the requirement of involving all relevant mathematical concepts.\n"
        },
        "25": {
            "formalization": "theory MaxValue\n  imports Complex_Main\nbegin\n\n  definition f :: \"real ⇒ real\" where\n    \"f t = (2^t - 3*t) * t / 4^t\"\n\n  lemma max_value: \"∃t. f t = 1/12\"\n    by (simp add: f_def)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Bad arguments on lhs: \"real t\"\nThe error(s) above occurred in definition:\n\"f (real t) \\<equiv> (2 ^ t - 3 * real t) * real t / 4 ^ t\"\n\nIdentified error on line: 9\nError message: Undefined fact: \"f_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization in Isabelle/HOL does not fully capture the mathematical statement. While it defines the function \\( f(t) \\) correctly, it only asserts the existence of a \\( t \\) such that \\( f(t) = \\frac{1}{12} \\) without demonstrating that this value is indeed the maximum of \\( f(t) \\) for all real \\( t \\). The original statement asks for the maximum value of the function, which requires a more comprehensive analysis, such as finding critical points and confirming that \\( \\frac{1}{12} \\) is the maximum value, rather than simply showing that there exists a \\( t \\) for which \\( f(t) = \\frac{1}{12} \\). Therefore, the formalization does not involve all necessary mathematical concepts from the natural language statement. \n"
        },
        "26": {
            "formalization": "theory Polynomial_Factorization\n  imports Main\nbegin\n\nlemma factorization_example:\n  assumes \"A * B = 10\" \"A * 3 + B * (-8) = -1\" \"A ∈ ℤ\" \"B ∈ ℤ\"\n  shows \"AB + B = 12\"\n  using assms(1) assms(2) by auto\n\nend\n",
            "error_details": "Identified error on line: 8\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. A * B = 10 \\<Longrightarrow> A * 3 - B * 8 = - 1 \\<Longrightarrow> AB + B = 12\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical concepts presented in the natural language statement. Specifically, while it correctly identifies the relationships involving \\( A \\) and \\( B \\) as integers and the equations derived from the factorization, it fails to explicitly state the requirement that \\( A \\) and \\( B \\) must be integers in the context of the factorization of the polynomial \\( 10x^2 - x - 24 \\). Additionally, the formalization does not include the expression \\( 10x^2 - x - 24 \\) or its factorization into \\( (Ax - 8)(Bx + 3) \\), which is crucial for understanding the context of the problem. Therefore, it does not involve all mathematical concepts from the original statement.\n"
        },
        "27": {
            "formalization": "theory Example\n  imports Main\nbegin\n\ndefinition n :: nat where\n  \"n = 3^17 + 3^10\"\n\nlemma \"11 divides (n + 1)\"\n  unfolding n_def\n  by (simp add: power_add)\n\ndefinition A :: nat where\n  \"A = 1\"  (* Example value, to be replaced with actual distinct digit *)\n  \ndefinition B :: nat where\n  \"B = 2\"  (* Example value, to be replaced with actual distinct digit *)\n\ndefinition C :: nat where\n  \"C = 9\"  (* Example value, to be replaced with actual distinct digit *)\n\nlemma distinct_digits: \"A ≠ B ∧ A ≠ C ∧ B ≠ C\"\n  unfolding A_def B_def C_def\n  by auto\n\nlemma odd_conditions: \"odd A ∧ odd C\"\n  unfolding A_def C_def\n  by auto\n\nlemma not_divisible_by_3: \"B mod 3 ≠ 0\"\n  unfolding B_def\n  by auto\n\nlemma find_100A_10B_C: \"100 * A + 10 * B + C = 129\"\n  unfolding A_def B_def C_def\n  by simp\n\nend\n",
            "error_details": "Identified error on line: 8\nError message: Type unification failed: No type arity fun :: numeral\n\nType error in application: operator not of function type\n\nOperator:  11 :: ??'a\nOperand:   divides :: ??'b\n\n\nIdentified error on line: 9\nError message: Bad context for command \"unfolding\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture all the mathematical concepts present in the natural language statement. While it defines \\( n \\) and verifies that \\( 11 \\) divides \\( n + 1 \\), it does not include the requirement that \\( A \\), \\( B \\), and \\( C \\) must be distinct digits, nor does it ensure that \\( A \\) and \\( C \\) are odd and that \\( B \\) is not divisible by \\( 3 \\) in a way that reflects the constraints of the problem. The definitions of \\( A \\), \\( B \\), and \\( C \\) are provided with example values, but these do not demonstrate the distinctness or the specific conditions required by the problem. Thus, the formalization lacks completeness in addressing all aspects of the original statement. \n"
        },
        "28": {
            "formalization": "theory Remainder_Example\n  imports Main\nbegin\n\nlemma remainder_54_mod_6: \"54 mod 6 = 0\"\n  by (simp add: mod_eq_0_iff_dvd)\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. 54 mod 6 = 0\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization correctly captures the mathematical concepts present in the natural language statement. It specifies the operation of finding the remainder of 54 when divided by 6, and it asserts that this remainder is 0. The use of the lemma and the simplification tactic effectively demonstrates the statement that the remainder is indeed 0, thus fulfilling the requirement of the original statement. All necessary components (the numbers involved, the modulus operation, and the conclusion about the remainder) are present in the formal code.\n"
        },
        "29": {
            "formalization": "theory Example\n  imports Real\nbegin\n\nlemma example:\n  assumes \"a ∈ ℝ\" \"b ∈ ℝ\" \"a^2 * b^3 = 32 / 27\" \"a / b^3 = 27 / 4\"\n  shows \"a + b = 8 / 3\"\n  using assms\n  by (simp add: field_simps)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It correctly assumes that \\(a\\) and \\(b\\) are real numbers, incorporates the equations \\(a^2b^3 = \\frac{32}{27}\\) and \\(\\frac{a}{b^3} = \\frac{27}{4}\\), and concludes with the statement that \\(a + b = \\frac{8}{3}\\). The use of the `assumes` keyword ensures that all necessary conditions are included, and the proof structure is appropriate for demonstrating the conclusion. Thus, the formalization meets the requirement of involving all mathematical concepts from the original statement.\n"
        },
        "30": {
            "formalization": "theory Sequence_Transformation\n  imports Complex_Main\nbegin\n\n  definition transformation :: \"real × real ⇒ real × real\" where\n    \"transformation (a, b) = (\\<sqrt>3 * a - b, \\<sqrt>3 * b + a)\"\n\n  definition sequence :: \"nat ⇒ real × real\" where\n    \"sequence n = (if n = 100 then (2, 4) else transformation (sequence (n + 1)))\"\n\n  lemma a1_b1_sum: \"sequence 1 = (1 / 2 ^ 98, -1 / 2 ^ 99) ⟹ fst (sequence 1) + snd (sequence 1) = 0\"\n    by (simp add: sequence_def transformation_def)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner lexical error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 8\nError message: Extra variables on rhs: \"sequence\", \"transformation\"\nThe error(s) above occurred in definition:\n\"sequence n \\<equiv> if n = 100 then (2, 4) else transformation (sequence (n + 1))\"\n\nIdentified error on line: 12\nError message: Undefined fact: \"sequence_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately capture the recursive nature of the sequence defined in the natural language statement. Specifically, the definition of `sequence` in the Isabelle/HOL code incorrectly uses `sequence (n + 1)` instead of `sequence (n - 1)` to compute previous terms, which is essential for tracing back to the initial conditions. Additionally, the lemma `a1_b1_sum` assumes that `sequence 1` equals a specific value without showing how to derive that from the transformation, thus failing to demonstrate the relationship between the initial terms and the final condition provided. Therefore, it does not involve all necessary mathematical concepts from the original statement. \n"
        },
        "31": {
            "formalization": "theory Irreducible_Fraction\n  imports Main \"~~/src/HOL/Number_Theory/Divisibility\"\nbegin\n\nlemma irreducible_fraction: \"n ∈ ℕ ⟹ gcd (21 * n + 4) (14 * n + 3) = 1\"\n  by (simp add: gcd.commute)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization correctly captures the essence of the natural language statement by proving that the greatest common divisor (gcd) of the numerator \\(21n + 4\\) and the denominator \\(14n + 3\\) is 1 for every natural number \\(n\\). This directly corresponds to the definition of an irreducible fraction, which requires that the numerator and denominator share no common factors other than 1. The use of the gcd function in the lemma aligns with the requirement of proving irreducibility, thus involving all necessary mathematical concepts from the original statement.\n"
        },
        "32": {
            "formalization": "theory AM_GM\n  imports Real\nbegin\n\nlemma am_gm: \"0 < b ⟹ b ≤ a ⟹ (a + b) / 2 - sqrt (a * b) ≤ (a - b) ^ 2 / (8 * b)\"\n  by (simp add: sqrt_le_iff)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It correctly identifies that \\(a\\) and \\(b\\) are positive real numbers and includes the condition \\(b \\leq a\\). The lemma states the inequality to be proven, which is \\(\\frac{a+b}{2} - \\sqrt{ab} \\leq \\frac{(a-b)^2}{8b}\\), aligning perfectly with the original statement. The use of the `simp` tactic with `sqrt_le_iff` suggests that the proof is leveraging the properties of square roots and inequalities, which are essential to the statement. Thus, all necessary concepts are included in the formalization.\n"
        },
        "33": {
            "formalization": "theory LCM_GCD\n  imports Main\nbegin\n\nlemma lcm_gcd_example:\n  assumes \"lcm 120 x = 3720\" and \"gcd 120 x = 8\"\n  shows \"x = 248\"\nproof -\n  have \"lcm 120 x * gcd 120 x = 120 * x\" using lcm_gcd[of 120 x] by auto\n  then have \"3720 * 8 = 120 * x\" using assms by auto\n  then have \"x = (3720 * 8) div 120\" by (simp add: divide_eq_iff)\n  also have \"3720 * 8 = 29760\" by simp\n  then have \"x = 29760 div 120\" by simp\n  also have \"29760 div 120 = 248\" by simp\n  finally show ?thesis by simp\nqed\n\nend\n",
            "error_details": "Identified error on line: 9\nError message: Type unification failed: Variable 'a::{gcd,numeral} not of sort semiring_gcd\n\nFailed to meet type constraint:\n\nTerm:  x :: 'a\nType:  ??'a\n\n\nIdentified error on line: 9\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. lcm 120 x * gcd 120 x = 120 * x\n\nIdentified error on line: 11\nError message: Type unification failed: Variable 'a::{gcd,numeral} not of sort {times,numeral,divide}\n\nType error in application: incompatible operand type\n\nOperator:  (=) x :: 'a \\<Rightarrow> bool\nOperand:   3720 * 8 div 120 :: ??'a\n\n\nIdentified error on line: 11\nError message: Illegal application of proof command in \"chain\" mode\n\nIdentified error on line: 12\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  3720 * 8 = 120 * x\ngoal (1 subgoal):\n 1. 3720 * 8 = 29760\n\nIdentified error on line: 13\nError message: Type unification failed: Variable 'a::{gcd,numeral} not of sort {numeral,divide}\n\nType error in application: incompatible operand type\n\nOperator:  (=) x :: 'a \\<Rightarrow> bool\nOperand:   29760 div 120 :: ??'a\n\n\nIdentified error on line: 13\nError message: Illegal application of proof command in \"chain\" mode\n\nIdentified error on line: 14\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  3720 * 8 = 29760\ngoal (1 subgoal):\n 1. 29760 div 120 = 248\n\nIdentified error on line: 15\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  29760 div 120 = 248\ngoal (1 subgoal):\n 1. x = 248\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It correctly incorporates the least common multiple (lcm) and greatest common divisor (gcd) of the two numbers, specifically stating that the lcm of 120 and the unknown number \\( x \\) is 3720 and the gcd is 8. The proof then logically derives the value of \\( x \\) as 248, which aligns with the requirement to show that this is the other number. Therefore, the formal code effectively encompasses all the necessary mathematical concepts from the original statement.\n"
        },
        "34": {
            "formalization": "theory Real_inequality\n  imports \"HOL.Real\"\nbegin\n\nlemma real_inequality: \"∀a b::real. (|a + b|) / (1 + |a + b|) ≤ (|a|) / (1 + |a|) + (|b|) / (1 + |b|)\"\n  by (auto simp: abs_add)\n  \nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 6\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code accurately captures all the mathematical concepts present in the natural language statement. It correctly states that for any real numbers \\(a\\) and \\(b\\), the inequality involving the absolute values and the specified fractions is to be shown. The use of universal quantification (∀) for \\(a\\) and \\(b\\) as real numbers is appropriate, and the inequality is correctly expressed in the formal language. The proof method employed (using `auto` and `simp`) is also suitable for demonstrating the inequality. Thus, all necessary concepts from the natural language statement are represented in the formalization.\n"
        },
        "35": {
            "formalization": "theory Solve_Equation\n  imports Main\nbegin\n\nlemma solve_equation:\n  assumes \"x - 9 = 2 * (x + 1)\"\n  shows \"x = -11\"\nproof -\n  have \"x - 9 = 2 * (x + 1)\" using assms by simp\n  then have \"x - 9 = 2 * x + 2\" by simp\n  then have \"x - 2 * x = 9 + 2\" by (simp add: algebra_simps)\n  then have \"-x = 11\" by simp\n  thus ?thesis by simp\nqed\n\nend\n",
            "error_details": "Identified error on line: 10\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. x - 9 = 2 * (x + 1) \\<Longrightarrow> 2 * (x + 1) = 2 * x + 2\n\nIdentified error on line: 11\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. x - 9 = 2 * x + 2 \\<Longrightarrow> x - 2 * x = 11\n\nIdentified error on line: 12\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. x - 2 * x = 11 \\<Longrightarrow> - x = 11\n\nIdentified error on line: 13\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  - x = 11\ngoal (1 subgoal):\n 1. x = - 11\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It correctly sets up the equation \\(\\frac{x-9}{x+1}=2\\) by transforming it into the equivalent form \\(x - 9 = 2 * (x + 1)\\) and proceeds to solve for \\(x\\). The proof demonstrates the steps leading to the conclusion that \\(x = -11\\), which is the solution requested in the natural language statement. Therefore, all necessary components of the problem are addressed in the formalization.\n"
        },
        "36": {
            "formalization": "theory System_of_Equations\n  imports Main\nbegin\n\n  definition a11 :: real where \"a11 = 1\"  (* Example positive coefficient *)\n  definition a22 :: real where \"a22 = 1\"  (* Example positive coefficient *)\n  definition a33 :: real where \"a33 = 1\"  (* Example positive coefficient *)\n\n  definition a12 :: real where \"a12 = -1\" (* Example negative coefficient *)\n  definition a13 :: real where \"a13 = -1\" (* Example negative coefficient *)\n  definition a21 :: real where \"a21 = -1\" (* Example negative coefficient *)\n  definition a23 :: real where \"a23 = -1\" (* Example negative coefficient *)\n  definition a31 :: real where \"a31 = -1\" (* Example negative coefficient *)\n  definition a32 :: real where \"a32 = -1\" (* Example negative coefficient *)\n\n  lemma unique_solution:\n    assumes \"a11 > 0\" \"a22 > 0\" \"a33 > 0\"\n    and \"a12 < 0\" \"a13 < 0\" \"a21 < 0\" \"a23 < 0\" \"a31 < 0\" \"a32 < 0\"\n    and \"a11 + a12 + a13 > 0\" \"a21 + a22 + a23 > 0\" \"a31 + a32 + a33 > 0\"\n    shows \"x1 = 0 ∧ x2 = 0 ∧ x3 = 0\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 6\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 7\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 9\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 10\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 11\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 12\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 13\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 14\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines the coefficients \\( a_{11}, a_{22}, a_{33} \\) as positive numbers and the remaining coefficients \\( a_{12}, a_{13}, a_{21}, a_{23}, a_{31}, a_{32} \\) as negative numbers, which aligns with the conditions stated in the problem. Additionally, the lemma includes the conditions that the sums of the coefficients in each equation are positive. Finally, it asserts the unique solution \\( x_1 = x_2 = x_3 = 0 \\), which is the conclusion required by the problem. Therefore, the formalization meets the aspect of involving all mathematical concepts from the natural language statement.\n"
        },
        "37": {
            "formalization": "theory Plumbing_Repair\n  imports Main\nbegin\n\n  definition charge :: \"nat ⇒ nat ⇒ nat\" where\n    \"charge N x = N + x\"\n\n  lemma charge_two_hour_job:\n    assumes \"charge N x = 97\" and \"charge N (5 * x) = 265\"\n    shows \"charge N (2 * x) = 139\"\n  proof -\n    have \"N + x = 97\" using assms(1) by (simp add: charge_def)\n    have \"N + 5 * x = 265\" using assms(2) by (simp add: charge_def)\n    then have \"5 * x = 265 - N\" by (simp add: charge_def)\n    then have \"x = (265 - N) div 5\" by (simp add: div_mult_eq)\n    then have \"N + 2 * x = N + 2 * ((265 - N) div 5)\" by (simp add: charge_def)\n    then show ?thesis by (simp add: charge_def)\n  qed\n\nend\n",
            "error_details": "Identified error on line: 15\nError message: Undefined fact: \"div_mult_eq\"\\<^here>\n\nIdentified error on line: 17\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. x = (265 - N) div 5 \\<Longrightarrow> N + 2 * ((265 - N) div 5) = 139\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It defines a function `charge` that models the total charge based on the fixed fee `N` and the hourly rate `x`. The lemma `charge_two_hour_job` uses the provided information about the charges for one-hour and five-hour jobs to derive the charge for a two-hour job. It correctly sets up the equations based on the charges given and manipulates them to find the required charge, ultimately showing that it equals \\$139. Thus, all relevant concepts from the natural language statement are included and addressed in the formalization.\n"
        },
        "38": {
            "formalization": "theory AC_Circuits\n  imports Complex_Main\nbegin\n\nlemma find_current:\n  assumes \"V = 1 + I * (2 - I)\"\n  and \"V = 1 + i\"\n  and \"Z = 2 - i\"\n  shows \"I = (1 / 5) + (3 / 5) * i\"\n  using assms\n  by (simp add: algebra_simps)\n\nend\n",
            "error_details": "Identified error on line: 11\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. 1 + i = 1 + I * (2 - I) \\<Longrightarrow>\n    V = 1 + I * (2 - I) \\<Longrightarrow> Z = 2 - i \\<Longrightarrow> I = 1 / 5 + 3 / 5 * i\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately capture the mathematical concepts presented in the natural language statement. Specifically, the assumption \"V = 1 + I * (2 - I)\" is incorrect as it misrepresents the relationship between voltage (V), current (I), and impedance (Z) in the equation $V = IZ$. The correct formulation should express that $I = V / Z$, which is not reflected in the provided code. Additionally, the formalization lacks explicit definitions or declarations for the variables involved (V, I, Z) and does not clearly state the context of AC circuits, which is a significant aspect of the original statement. Thus, it fails to encompass all the necessary mathematical concepts.\n"
        },
        "39": {
            "formalization": "theory Sum_of_Prime_Divisors\n  imports \"HOL/Number_Theory/Divisors\"\nbegin\n\nlemma sum_of_prime_divisors_of_sum_of_divisors_500:\n  shows \"sum_of_prime_divisors (sum_of_divisors 500) = 25\"\n  by (simp add: sum_of_divisors_def)\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It defines a lemma that states the sum of the distinct prime divisors of the sum of the positive divisors of 500 equals 25. The use of `sum_of_divisors` directly corresponds to the sum of the positive divisors of 500, and `sum_of_prime_divisors` addresses the requirement to find the sum of distinct prime divisors of that sum. Thus, all necessary components of the original statement are included in the formalization.\n"
        },
        "40": {
            "formalization": "theory Function_F\n  imports Main\nbegin\n\n  fun f :: \"nat ⇒ nat\" where\n    \"f 2 = 0\" |\n    \"f 3 = Suc 0\" |  (* f(3) > 0 *)\n    \"f 9999 = 3333\" |\n    \"f (m + n) = f m + f n + (if f m + f n + 0 < f (m + n) then 1 else 0)\"\n\n  lemma f_1982: \"f 1982 = 660\"\n  proof -\n    (* Proof goes here *)\n  qed\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Malformed definition:\nNon-constructor pattern not allowed in sequential mode.\nf 2 = 0\n\nIdentified error on line: 14\nError message: Failed to finish proof:\ngoal (1 subgoal):\n 1. f 1982 = 660\n\nIdentified error on line: 16\nError message: Bad context for command \"end\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It defines the function \\( f(n) \\) on the positive integers, specifies the values for \\( f(2) \\), \\( f(3) \\), and \\( f(9999) \\), and incorporates the condition \\( f(m+n) - f(m) - f(n) = 0 \\text{ or } 1 \\) through the recursive definition of \\( f \\). Additionally, the lemma \\( f(1982) = 660 \\) is included, aligning with the requirement to determine and show the value of \\( f(1982) \\). Thus, all aspects of the original statement are addressed in the formalization.\n"
        },
        "41": {
            "formalization": "theory Enrollment\n  imports Main\nbegin\n\n  definition last_year_enrollment :: real where\n    \"last_year_enrollment = 598 / (1 + 0.04)\"\n\n  lemma last_year_enrollment_value: \"last_year_enrollment = 575\"\n    by (simp add: last_year_enrollment_def)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 9\nError message: Undefined fact: \"last_year_enrollment_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines the last year's enrollment based on the increase of 4% from the current enrollment of 598 students. The definition correctly implements the formula for calculating last year's enrollment, and the lemma verifies that this calculation results in 575 students, which aligns with the statement's requirement to show that last year's enrollment is 575 students. Therefore, all key concepts from the natural language statement are addressed in the formalization.\n"
        },
        "42": {
            "formalization": "theory Inequality_Example\n  imports Main\nbegin\n\nlemma inequality_example:\n  assumes \"1 - sqrt (2 * x + 1) > 0\"\n  shows \"4 * x^2 < (2 * x + 9) * (1 - sqrt (2 * x + 1))^2\"\n  using assms by (simp add: field_simps)\n\nend\n",
            "error_details": "Identified error on line: 8\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  0 < 1 - sqrt (2 * x + 1)\ngoal (1 subgoal):\n 1. 4 * x\\<^sup>2 < (2 * x + 9) * (1 - sqrt (2 * x + 1))\\<^sup>2\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the original mathematical statement. The natural language statement asks for the values of \\( x \\) for which the inequality holds, but the Isabelle/HOL code only provides a lemma that assumes a condition and shows a specific inequality. It does not address the requirement to find all values of \\( x \\) that satisfy the inequality, nor does it explicitly state the inequality in the same form as presented in the natural language statement. Therefore, it lacks the necessary components to fully represent the original statement.\n"
        },
        "43": {
            "formalization": "theory Consecutive_Even_Numbers\n  imports Main\nbegin\n\nlemma sum_of_squares_even_numbers:\n  assumes \"x > 0\" and \"even x\"\n  shows \"((x^2) + ((x + 2)^2) + ((x + 4)^2)) = 12296 ⟹ (x * (x + 2) * (x + 4)) div 8 = 32736\"\nproof -\n  have \"x^2 + (x + 2)^2 + (x + 4)^2 = x^2 + (x^2 + 4x + 4) + (x^2 + 8x + 16)\"\n    by simp\n  then have \"3 * x^2 + 12 * x + 20 = 12296\"\n    by simp\n  then have \"3 * x^2 + 12 * x - 12276 = 0\"\n    by simp\n  then have \"x = 38\" \n    using quadratic_formula by auto\n  then have \"x * (x + 2) * (x + 4) = 38 * 40 * 42\"\n    by simp\n  then show ?thesis\n    by (simp add: divide_simps)\nqed\n\nend\n",
            "error_details": "Identified error on line: 9\nError message: Type unification failed: No type arity fun :: numeral\n\nType error in application: operator not of function type\n\nOperator:  4 :: ??'a\nOperand:   x :: 'a\n\n\nIdentified error on line: 10\nError message: Illegal application of proof command in \"state\" mode\n\nIdentified error on line: 11\nError message: No current facts available\n\nIdentified error on line: 12\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. 3 * x\\<^sup>2 + 12 * x + 20 = 12296\n\nIdentified error on line: 14\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  3 * x\\<^sup>2 + 12 * x + 20 = 12296\ngoal (1 subgoal):\n 1. 3 * x\\<^sup>2 + 12 * x - 12276 = 0\n\nIdentified error on line: 16\nError message: Undefined fact: \"quadratic_formula\"\\<^here>\n\nIdentified error on line: 16\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  3 * x\\<^sup>2 + 12 * x - 12276 = 0\ngoal (1 subgoal):\n 1. x = 38\n\nIdentified error on line: 20\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. x * (x + 2) * (x + 4) = 63840 \\<Longrightarrow> 63840 div 8 = 32736\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It defines three consecutive positive even numbers starting from an even number \\( x \\), calculates the sum of their squares, and checks if it equals 12296. It then computes the product of these three numbers and verifies that dividing this product by 8 yields 32736. The key elements of the problem, including the conditions of positivity and evenness, the specific sum of squares, and the final product calculation, are all addressed in the formal code.\n"
        },
        "44": {
            "formalization": "theory Intersection\n  imports Main\nbegin\n\n  definition s :: \"real\" where \"s = 1\"\n  definition t :: \"real\" where \"t = 4\"\n\n  lemma intersection: \"s = 9 - 2 * t ∧ t = 3 * s + 1\"\n  proof -\n    have \"s = 1\" and \"t = 4\" by (simp add: s_def t_def)\n    thus ?thesis\n      by (simp add: s_def t_def)\n  qed\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 6\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 10\nError message: Undefined fact: \"s_def\"\\<^here>\n\nIdentified error on line: 12\nError message: Undefined fact: \"s_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical concepts presented in the natural language statement. While it defines the variables \\(s\\) and \\(t\\) and provides a lemma to show that these values satisfy the equations of the lines, it does not explicitly address the process of finding the intersection point of the two lines. The natural language statement asks for the intersection point, which implies solving the equations simultaneously, but the formal code simply assumes the values of \\(s\\) and \\(t\\) without demonstrating the intersection through solving the equations. Therefore, it lacks the necessary steps to show how the intersection point is derived from the given equations. \n"
        },
        "45": {
            "formalization": "theory PolynomialRoots\n  imports Complex_Main\nbegin\n\nlemma roots_cosine:\n  assumes \"P = (λx. x^3 + a * x^2 + b * x + c)\"\n  shows \"P (cos (2 * π / 7)) = 0 ∧ P (cos (4 * π / 7)) = 0 ∧ P (cos (6 * π / 7)) = 0\"\n  and \"abc = 1 / 32\"\n  \nend\n",
            "error_details": "Identified error on line: 10\nError message: Bad context for command \"end\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It defines a polynomial \\( P(x) \\) with roots specified as \\( \\cos \\frac{2\\pi}{7} \\), \\( \\cos \\frac{4\\pi}{7} \\), and \\( \\cos \\frac{6\\pi}{7} \\), which corresponds directly to the roots mentioned in the statement. Additionally, it asserts that the product \\( abc \\) equals \\( \\frac{1}{32} \\), which is the conclusion drawn from the problem. Therefore, the formalization includes all necessary components: the polynomial structure, the specific roots, and the calculation of \\( abc \\).\n"
        },
        "46": {
            "formalization": "theory Complex_Square\n  imports Complex_Main\nbegin\n\nlemma square_of_i_div_2: \"(\\<frac>i 2) ^ 2 = -\\<frac>1 4\"\n  by (simp add: complex_div_def power2_eq_square)\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner lexical error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 6\nError message: Bad context for command \"by\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code in Isabelle/HOL accurately captures the mathematical statement provided in natural language. It evaluates the expression \\(\\left(\\frac{i}{2}\\right)^2\\) and demonstrates that it equals \\(-\\frac{1}{4}\\). The lemma `square_of_i_div_2` explicitly states the equality that needs to be proven, and the proof uses the `simp` tactic along with the necessary definitions from the `Complex_Main` theory, ensuring that all relevant mathematical concepts are included. Thus, the formalization meets the aspect of involving all mathematical concepts from the natural language statement.\n"
        },
        "47": {
            "formalization": "theory Modulo_Computation\n  imports Main\nbegin\n\nlemma compute_modulo: \"29^13 - 5^13 mod 7 = 3\"\n  by (simp add: mod_eq_0_iff_dvd)\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. 29 ^ 13 - 5 ^ 13 mod 7 = 3\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not correctly represent the modulo operation in the context of the statement. The expression \"29^13 - 5^13 mod 7\" is not properly formatted in Isabelle/HOL, as it lacks parentheses to clarify the order of operations. The correct representation should be \"(29^13 - 5^13) mod 7 = 3\" to ensure that the subtraction is performed before applying the modulo operation. Additionally, the lemma does not explicitly show the computation steps or reasoning leading to the conclusion that the result is 3, which is part of the requirement to \"show\" the result. Therefore, the formalization fails to involve all mathematical concepts from the natural language statement adequately.\n"
        },
        "48": {
            "formalization": "theory Patio\n  imports Main\nbegin\n\n  definition area :: \"real ⇒ real ⇒ real\" where\n    \"area l w = l * w\"\n\n  definition perimeter :: \"real ⇒ real ⇒ real\" where\n    \"perimeter l w = 2 * (l + w)\"\n\n  lemma diagonal_squared:\n    assumes \"area l w = 180\" and \"perimeter l w = 54\"\n    shows \"l^2 + w^2 = 369\"\n  proof -\n    from assms(1) have \"l * w = 180\" by (simp add: area_def)\n    from assms(2) have \"l + w = 27\" by (simp add: perimeter_def)\n    obtain l w where \"l + w = 27\" and \"l * w = 180\" by (metis assms(1) assms(2) area_def perimeter_def)\n    then have \"l^2 + w^2 = (l + w)^2 - 2 * l * w\" by (metis algebra_simps)\n    then show ?thesis using `l + w = 27` `l * w = 180` by auto\n  qed\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 8\nError message: Undefined type name: \"real\"\\<^here>\nFailed to parse type\n\nIdentified error on line: 15\nError message: Undefined fact: \"area_def\"\\<^here>\n\nIdentified error on line: 16\nError message: Undefined fact: \"perimeter_def\"\\<^here>\n\nIdentified error on line: 17\nError message: Undefined fact: \"area_def\"\\<^here>\n\nIdentified error on line: 18\nError message: Type unification failed: Variable 'd::{times,numeral} not of sort power\n\nType error in application: incompatible operand type\n\nOperator:  (^) :: ??'a \\<Rightarrow> nat \\<Rightarrow> ??'a\nOperand:   l :: 'd\n\n\nIdentified error on line: 18\nError message: Illegal application of proof command in \"chain\" mode\n\nIdentified error on line: 19\nError message: Illegal application of proof command in \"chain\" mode\n\nIdentified error on line: 19\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. l + w = 27 \\<Longrightarrow> l * w = 180 \\<Longrightarrow> l\\<^sup>2 + w\\<^sup>2 = 369\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It defines the area and perimeter of a rectangle in terms of its length (l) and width (w), and it uses these definitions to derive the relationship needed to calculate the square of the diagonal. The lemma correctly assumes the area and perimeter values given in the problem and shows that the expression for the square of the diagonal (l^2 + w^2) equals 369, which is the required result. Thus, all relevant mathematical concepts from the statement are addressed in the formalization.\n"
        },
        "49": {
            "formalization": "theory Example\n  imports Main\nbegin\n\nlemma sqrt_example: \"sqrt (19 + 3 * 10) = 7\"\n  by (simp add: sqrt_def)\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Undefined fact: \"sqrt_def\"\\<^here>\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not involve the variable \\( y \\) as stated in the natural language statement. Instead, it directly substitutes \\( y \\) with the value 10 in the lemma, which does not demonstrate the process of finding \\( y \\) such that \\( \\sqrt{19 + 3y} = 7 \\). The formal code fails to capture the requirement of solving for \\( y \\) and does not show the steps leading to the conclusion that \\( y = 10 \\). Therefore, it does not encompass all the mathematical concepts presented in the original statement.\n"
        }
    },
    "3-shot": {
        "0": {
            "formalization": "theory amc12a_2009_p4 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2009_p4:\n  fixes n :: nat\n  assumes \"n! mod 80325 = 0\"\n  shows \"n = 17\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 10\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical concepts present in the natural language statement. While it correctly states that \\( n! \\) must be divisible by \\( 80325 \\) and concludes that \\( n = 17 \\), it lacks the necessary context and reasoning to demonstrate that \\( 17 \\) is indeed the least positive integer satisfying this condition. The statement should also include the process of determining the least \\( n \\) such that \\( 80325 \\) divides \\( n! \\), which involves prime factorization and analysis of factorial growth. The current formalization only asserts the conclusion without providing the required justification or exploration of the conditions leading to it.\n"
        },
        "1": {
            "formalization": "theory divisibility_theorem imports\n  Complex_Main\nbegin\n\ntheorem divisibility_by_11:\n  fixes n :: nat\n  shows \"11 dvd (10^n - (-1)^n)\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts present in the natural language statement. It correctly identifies the variable \\( n \\) as a natural number and asserts that \\( 11 \\) divides the expression \\( 10^n - (-1)^n \\). The use of the Isabelle/HOL syntax for divisibility (using `dvd`) aligns with the mathematical statement's requirement. The formal code is structured to prove the theorem, which is consistent with the goal of showing the divisibility condition for any natural number \\( n \\). Therefore, it meets the aspect of involving all mathematical concepts from the natural language statement.\n"
        },
        "2": {
            "formalization": "theory congruence_example imports\n  Complex_Main\nbegin\n\ntheorem congruence_solution:\n  fixes n :: nat\n  assumes \"3 * n mod 11 = 2\"\n  shows \"n mod 11 = 8\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It correctly sets up the congruence equation \\(3n \\equiv 2 \\pmod{11}\\) using the assumption \\(3 * n mod 11 = 2\\). The conclusion \\(n \\mod 11 = 8\\) directly corresponds to the requirement to show that the solution is 8, which is within the specified range of 0 to 10. Therefore, the formal code involves all necessary mathematical concepts from the original statement.\n"
        },
        "3": {
            "formalization": "theory euler_polynomial imports Complex_Main\nbegin\n\ntheorem euler_polynomial:\n  fixes n :: nat\n  defines \"p n ≡ n^2 - n + 41\"\n  assumes \"∃ n. gcd (p n) (p (n + 1)) > 1\"\n  shows \"n = 41\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Bad arguments on lhs: \"n\"\nThe error(s) above occurred in definition:\n\"p n \\<equiv> n\\<^sup>2 - n + 41\"\n\nIdentified error on line: 10\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical concepts present in the natural language statement. Specifically, the statement mentions finding the smallest positive integer \\( n \\) such that \\( p(n) \\) and \\( p(n+1) \\) share a common factor greater than 1, and it concludes that this integer is 41. However, the formal code does not include the requirement to find the smallest \\( n \\); it only asserts the existence of such an \\( n \\) and states that \\( n \\) must equal 41 without demonstrating the process of finding the smallest \\( n \\). Therefore, the formalization lacks the necessary detail to encompass all aspects of the original statement. \n"
        },
        "4": {
            "formalization": "theory minimum_value imports Complex_Main\nbegin\n\ntheorem minimum_value:\n  fixes x :: real\n  assumes \"x^2 - 14*x + 3\"\n  shows \"x = 7\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Type unification failed: Clash of types \"real\" and \"bool\"\n\nType error in application: incompatible operand type\n\nOperator:  Trueprop :: bool \\<Rightarrow> prop\nOperand:   x\\<^sup>2 - 14 * x + 3 :: real\n\nCoercion Inference:\n\nLocal coercion insertion on the operand failed:\n\"real\" is not a subtype of \"bool\"\n\nNow trying to infer coercions globally.\n\nCoercion inference failed:\nassigned base type \"real\" clashes with the upper bound of variable ??'a9\n\nCannot fulfil subtype constraints:\n  ??'a  <:  bool   from function application  x ^ 2 - 14 * x + 3\n  ??'a  <:  ??'b   from function application  x ^ 2 - 14 * x + 3\n  ??'a  <:  ??'b   from function application  (+) (x ^ 2 - 14 * x)\n\nIdentified error on line: 9\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately capture all the mathematical concepts present in the natural language statement. Specifically, it fails to establish that the expression \\(x^2 - 14x + 3\\) is a quadratic function and does not demonstrate the process of finding the minimum value, which involves completing the square or using calculus. The assumption \"x^2 - 14*x + 3\" is not a valid assumption in this context, as it does not specify a condition or a property to be proven. Additionally, the theorem simply states \"x = 7\" without providing justification or showing that this value indeed minimizes the quadratic expression. Therefore, the formalization is incomplete and does not encompass all necessary mathematical concepts. \n"
        },
        "5": {
            "formalization": "theory amc10_2009_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2009_p5:\n  fixes x :: real\n  assumes \"sec x + tan x = 22 / 7\"\n  shows \"csc x + cot x = 44 / 7\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the requirements of the natural language statement. While it correctly states the assumption that \\(\\sec x + \\tan x = \\frac{22}{7}\\) and aims to show that \\(\\csc x + \\cot x = \\frac{44}{7}\\), it fails to address the requirement that \\(\\frac{m}{n}\\) must be in lowest terms and does not explicitly mention the need to find \\(m+n\\). Additionally, the formal code does not provide a proof or justification for the conclusion, as indicated by the \"sorry\" placeholder. Therefore, it does not involve all the mathematical concepts present in the original statement.\n"
        },
        "6": {
            "formalization": "theory integer_values imports Complex_Main\nbegin\n\ntheorem integer_values:\n  fixes x :: real\n  assumes \"abs x < 3 * pi\"\n  shows \"x \\<in> { -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }\"\n  using assms by auto\n\nend\n",
            "error_details": "Identified error on line: 9\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> < 3 * pi \\<Longrightarrow>\n    x \\<noteq> - 18 \\<Longrightarrow>\n    x \\<noteq> - 17 \\<Longrightarrow>\n    x \\<noteq> - 16 \\<Longrightarrow>\n    x \\<noteq> - 15 \\<Longrightarrow>\n    x \\<noteq> - 14 \\<Longrightarrow>\n    x \\<noteq> - 13 \\<Longrightarrow>\n    x \\<noteq> - 12 \\<Longrightarrow>\n    x \\<noteq> - 11 \\<Longrightarrow>\n    x \\<noteq> - 10 \\<Longrightarrow>\n    x \\<noteq> - 9 \\<Longrightarrow>\n    x \\<noteq> - 8 \\<Longrightarrow>\n    x \\<noteq> - 7 \\<Longrightarrow>\n    x \\<noteq> - 6 \\<Longrightarrow>\n    x \\<noteq> - 5 \\<Longrightarrow>\n    x \\<noteq> - 4 \\<Longrightarrow>\n    x \\<noteq> - 3 \\<Longrightarrow>\n    x \\<noteq> - 2 \\<Longrightarrow>\n    x \\<noteq> - 1 \\<Longrightarrow>\n    x \\<noteq> 0 \\<Longrightarrow>\n    x \\<noteq> 1 \\<Longrightarrow>\n    x \\<noteq> 2 \\<Longrightarrow>\n    x \\<noteq> 3 \\<Longrightarrow>\n    x \\<noteq> 4 \\<Longrightarrow>\n    x \\<noteq> 5 \\<Longrightarrow>\n    x \\<noteq> 6 \\<Longrightarrow>\n    x \\<noteq> 7 \\<Longrightarrow>\n    x \\<noteq> 8 \\<Longrightarrow>\n    x \\<noteq> 9 \\<Longrightarrow>\n    x \\<noteq> 10 \\<Longrightarrow>\n    x \\<noteq> 11 \\<Longrightarrow> x \\<noteq> 12 \\<Longrightarrow> x \\<noteq> 13 \\<Longrightarrow> x \\<noteq> 14 \\<Longrightarrow> x \\<noteq> 15 \\<Longrightarrow> x \\<noteq> 16 \\<Longrightarrow> x \\<noteq> 18 \\<Longrightarrow> x = 17\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately capture the requirement to find the integer values of \\( x \\) that satisfy the condition \\( |x| < 3\\pi \\). While it correctly sets up the theorem with the assumption \\( \\text{abs } x < 3 * \\pi \\), it explicitly lists the integer values from -18 to 18, which does not account for the correct range derived from \\( 3\\pi \\). The actual integer values satisfying \\( |x| < 3\\pi \\) should be calculated based on the numerical approximation of \\( 3\\pi \\) (approximately 9.42), leading to integer values from -9 to 9, which totals 19 integers. The formalization fails to show the calculation or reasoning leading to this conclusion, thus missing the necessary mathematical concepts involved in the original statement.\n"
        },
        "7": {
            "formalization": "theory amc12a_2008_p5 imports Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes x :: real\n  assumes \"(x + 3)^2 = 121\"\n  shows \"x + x = -6\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not correctly capture all the mathematical concepts present in the natural language statement. Specifically, the statement asks for the sum of the two values of \\( x \\) that satisfy the equation \\( (x+3)^2 = 121 \\). However, the formal code only assumes the equation and directly states that \\( x + x = -6 \\), which is incorrect. The correct approach should involve solving the equation to find the two values of \\( x \\) (which are \\( 8 \\) and \\( -12 \\)), and then summing these values to show that their sum is indeed \\( -6 \\). The formalization lacks the necessary steps to derive the values of \\( x \\) and their sum, thus failing to meet the requirement of involving all mathematical concepts from the natural language statement. \n"
        },
        "8": {
            "formalization": "theory polynomial_expansion imports Complex_Main\nbegin\n\ntheorem polynomial_expansion:\n  shows \"((x + 1)^2) * x = x^3 + 2 * x^2 + x\"\n  by (simp add: algebra_simps)\n\nend\n",
            "error_details": "Identified error on line: 7\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. (x + 1)\\<^sup>2 * x = x ^ 3 + (2 * x\\<^sup>2 + x)\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL accurately captures all the mathematical concepts presented in the natural language statement. It expands the product \\((x+1)^2 \\cdot x\\) and demonstrates that it equals \\(x^3 + 2x^2 + x\\). The theorem statement directly corresponds to the assertion made in the natural language, and the proof using simplification (simp) confirms the equality. Therefore, all relevant mathematical concepts are included in the formalization.\n"
        },
        "9": {
            "formalization": "theory prime_divides imports\n  Complex_Main\nbegin\n\ntheorem prime_divides:\n  fixes p :: nat and a :: nat\n  assumes \"prime p\" and \"a > 0\"\n  shows \"p dvd (a^p - a)\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the essential mathematical concepts from the natural language statement. It defines a prime number \\( p \\) and a positive integer \\( a \\), and it states the theorem that \\( p \\) divides \\( a^p - a \\). The assumptions \"prime p\" and \"a > 0\" correspond directly to the conditions given in the natural language statement. The conclusion \"p dvd (a^p - a)\" correctly reflects the divisibility condition that needs to be shown. Therefore, the formalization meets the aspect of involving all mathematical concepts present in the original statement.\n"
        },
        "10": {
            "formalization": "theory units_digit_sum_of_squares imports\n  Complex_Main\nbegin\n\ntheorem units_digit_sum_of_squares:\n  shows \"(\\<Sum>n=1..9. n^2) mod 10 = 5\"\n  proof -\n    have \"(\\<Sum>n=1..9. n^2) = 1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2\"\n      by simp\n    also have \"... = 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81\"\n      by simp\n    finally have \"(\\<Sum>n=1..9. n^2) = 285\" by simp\n    thus ?thesis by simp\n  qed\n\nend\n",
            "error_details": "Identified error on line: 10\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. sum power2 {1..9} = 1\\<^sup>2 + 2\\<^sup>2 + 3\\<^sup>2 + 4\\<^sup>2 + 5\\<^sup>2 + 6\\<^sup>2 + 7\\<^sup>2 + 8\\<^sup>2 + 9\\<^sup>2\n\nIdentified error on line: 12\nError message: Failed to finish proof\\<^here>:\ngoal (1 subgoal):\n 1. 1\\<^sup>2 + 2\\<^sup>2 + 3\\<^sup>2 + 4\\<^sup>2 + 5\\<^sup>2 + 6\\<^sup>2 + 7\\<^sup>2 + 8\\<^sup>2 + 9\\<^sup>2 = 285\n\nIdentified error on line: 14\nError message: Failed to apply initial proof method\\<^here>:\nusing this:\n  sum power2 {1..9} = 285\ngoal (1 subgoal):\n 1. sum power2 {1..9} mod 10 = 5\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It correctly computes the sum of the squares of the first nine positive integers and shows that the units digit of this sum is 5. The theorem statement directly reflects the question posed in the natural language, and the proof provides a clear calculation leading to the conclusion. Therefore, all relevant mathematical concepts are included in the formalization.\n"
        },
        "11": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes A B C :: nat\n  assumes \"A + B = C\"\n      and \"10 * A + A - B = 2 * C\"\n      and \"C * B = 10 * A + A + A\"\n      and \"A > 0\" and \"B > 0\" and \"C > 0\" and \"A \\<noteq> B\" and \"B \\<noteq> C\" and \"A \\<noteq> C\"\n  shows \"A + B + C = 8\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines three distinct digits \\( A \\), \\( B \\), and \\( C \\) as natural numbers (with the assumption that they are greater than 0), and it includes the necessary equations: \\( A + B = C \\), \\( AA - B = 2 \\times C \\) (represented as \\( 10 \\times A + A - B = 2 \\times C \\)), and \\( C \\times B = AA + A \\) (represented as \\( C \\times B = 10 \\times A + A + A \\)). Additionally, it includes the distinctness conditions \\( A \\neq B \\), \\( B \\neq C \\), and \\( A \\neq C \\). Therefore, the formalization meets the aspect of involving all mathematical concepts from the natural language statement.\n"
        },
        "12": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  shows \"(\\<prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Inner lexical error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 8\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code in Isabelle/HOL captures the essence of the natural language statement by expressing the product of all positive odd integers less than 10000 as a mathematical expression. The notation used in the theorem correctly represents the product of the sequence of odd integers, which is equivalent to the expression given in option (D) of the natural language statement. The formalization includes all necessary mathematical concepts: the product of integers, the factorial function, and the division by powers of 2 and factorials, which are all present in the original statement. Therefore, it meets the requirement of involving all mathematical concepts from the natural language statement.\n"
        },
        "13": {
            "formalization": "theory inequality_solution imports Complex_Main\nbegin\n\ntheorem inequality_solution:\n  fixes x :: real\n  assumes \"abs (x - 2) ≤ 5.6\"\n  shows \"card {n :: int. 2 - 5.6 ≤ real n ∧ real n ≤ 2 + 5.6} = 11\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Type unification failed: Clash of types \"nat\" and \"int\"\n\nFailed to meet type constraint:\n\nTerm:  \\<lambda>n. 2 - 56 / 10 \\<le> real n \\<and> real n \\<le> 2 + 56 / 10 :: nat \\<Rightarrow> bool\nType:  int \\<Rightarrow> ??'a\n\nCoercion Inference:\n\nLocal coercion insertion on the operand failed:\n\"int\" is not a subtype of \"nat\"\n\nNow trying to infer coercions globally.\n\nCoercion inference failed:\nassigned base type \"int\" clashes with the upper bound of variable ??'a33\n\nCannot fulfil subtype constraints:\n  int \\<Rightarrow> bool  <:  ??'a \\<Rightarrow> bool   from function application\n    {n. 2 - 56 / 10 \\<le> real n \\<and> real n \\<le> 2 + 56 / 10}\n  ??'a set \\<Rightarrow> nat  <:  ??'a set \\<Rightarrow> ??'b   from function application  card\n  nat \\<Rightarrow> real  <:  ??'a \\<Rightarrow> ??'b   from function application  real\n  nat \\<Rightarrow> real  <:  ??'a \\<Rightarrow> ??'b   from function application  real\n  ??'a  <:  ??'b   from function application  real n\n  ??'a  <:  ??'b   from function application  n\n  ??'a  <:  ??'b   from function application  real n\n  ??'a  <:  ??'b   from function application  n\n  ??'a \\<Rightarrow> bool  <:  ??'b \\<Rightarrow> bool   from function application\n    \\<lambda>n. 2 - 56 / 10 \\<le> real n \\<and> real n \\<le> 2 + 56 / 10\n  ??'a \\<Rightarrow> bool  <:  int \\<Rightarrow> bool   from function application\n    \\<lambda>n. 2 - 56 / 10 \\<le> real n \\<and> real n \\<le> 2 + 56 / 10\n\nIdentified error on line: 9\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It defines the variable \\( x \\) as a real number and establishes the inequality \\( |x - 2| \\leq 5.6 \\). The code then correctly identifies the set of integers \\( n \\) that satisfy the equivalent conditions derived from the absolute value inequality, specifically \\( 2 - 5.6 \\leq n \\leq 2 + 5.6 \\). Finally, it asserts that the cardinality of this set is 11, which aligns with the requirement to show that there are 11 integers in the solution set. Thus, all necessary mathematical concepts are included in the formalization.\n"
        },
        "14": {
            "formalization": "theory triangle_inequality imports\n  Complex_Main\nbegin\n\ntheorem triangle_inequality:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ≥ 0\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the requirement of the natural language statement. While it correctly states the inequality involving the lengths of the sides of a triangle, it fails to address the condition for equality, which is explicitly requested in the natural language statement. The formal code only presents the inequality without any mention or exploration of the circumstances under which equality holds, which is a crucial part of the original statement.\n"
        },
        "15": {
            "formalization": "theory system_of_equations imports Complex_Main\nbegin\n\ntheorem system_of_equations:\n  fixes a b c :: real\n  assumes \"3*a + b + c = -3\"\n      and \"a + 3*b + c = 9\"\n      and \"a + b + 3*c = 19\"\n  shows \"a * b * c = -56\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It includes the three equations involving the variables \\(a\\), \\(b\\), and \\(c\\), which are necessary to establish the system of equations. The formal code also correctly states the conclusion that \\(abc = -56\\), which is the result that needs to be shown. The assumptions and the conclusion are appropriately represented, thus fulfilling the requirement to involve all mathematical concepts from the original statement.\n"
        },
        "16": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  defines \"D n = (if n = 0 then 0 else if n = 1 then 0 else if n = 2 then 1 else D (n - 1) + D (n - 3))\"\n  shows \"D 2021 mod 2 = 0 \\<and> D 2022 mod 2 = 1 \\<and> D 2023 mod 2 = 0\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Not a meta-equality (\\<equiv>)\nThe error(s) above occurred in definition:\n\"D n =\n (if n = 0 then 0\n  else if n = 1 then 0 else if n = 2 then 1 else D (n - 1) + D (n - 3))\"\n\nIdentified error on line: 9\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the essential mathematical concepts from the natural language statement. It defines the sequence \\(D_n\\) according to the specified initial conditions and recurrence relation. The theorem asserts the parities of \\(D_{2021}\\), \\(D_{2022}\\), and \\(D_{2023}\\) in terms of modulo 2, which directly corresponds to the requirement to determine whether these numbers are even or odd. The formalization aligns with the natural language statement by addressing the sequence definition and the specific parities of the numbers in question, thus meeting the aspect of involving all mathematical concepts. \n"
        },
        "17": {
            "formalization": "theory functional_inverse imports\n  Complex_Main\nbegin\n\ntheorem functional_inverse:\n  fixes f h :: \"real ⇒ real\"\n  assumes \"h = f^-1\"\n  and \"h 2 = 10\"\n  and \"h 10 = 1\"\n  and \"h 1 = 2\"\n  shows \"f (f 10) = 1\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Type unification failed: Clash of types \"_ \\<Rightarrow> _\" and \"_ set\"\n\nType error in application: incompatible operand type\n\nOperator:  converse :: (??'a \\<times> ??'b) set \\<Rightarrow> (??'b \\<times> ??'a) set\nOperand:   f :: real \\<Rightarrow> real\n\nCoercion Inference:\n\nLocal coercion insertion on the operand failed:\nNo coercion known for type constructors: \"fun\" and \"set\"\n\nIdentified error on line: 13\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines the function \\( h \\) as the inverse of \\( f \\) (i.e., \\( h = f^{-1} \\)), and it includes the specific values of \\( h \\) at 2, 10, and 1, which are crucial for determining \\( f(f(10)) \\). The theorem statement correctly asserts that \\( f(f(10)) = 1 \\), aligning with the conclusion of the natural language statement. Therefore, all necessary mathematical concepts are present in the formalization.\n"
        },
        "18": {
            "formalization": "theory amc10_2006_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2006_p5:\n  fixes n :: nat\n  assumes \"n = 9\"\n  shows \"count_perfect_squares (prod_factorials n) = 672\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization provided in Isabelle/HOL does not fully capture the mathematical concepts present in the natural language statement. While it correctly identifies the product of factorials up to 9 and the goal of counting perfect square divisors, it lacks the necessary details about how to compute the product of factorials and the method for counting perfect squares. Additionally, the formalization does not explicitly define or utilize the function `count_perfect_squares` or `prod_factorials`, which are crucial to understanding the problem. Therefore, it does not encompass all the mathematical concepts involved in the original statement.\n"
        },
        "19": {
            "formalization": "theory amc12a_2001_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2001_p5:\n  fixes I M O :: nat\n  assumes \"I * M * O = 2001\" and \"I \\<noteq> M\" and \"M \\<noteq> O\" and \"I \\<noteq> O\"\n  shows \"I + M + O \\<le> 671\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 10\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the requirements of the natural language statement. While it correctly states that \\(I\\), \\(M\\), and \\(O\\) are distinct positive integers whose product equals 2001, it fails to address the goal of finding the largest possible value of the sum \\(I + M + O\\). Instead, it only shows that \\(I + M + O \\leq 671\\) without demonstrating that 671 is indeed the maximum sum achievable under the given conditions. Therefore, the formalization does not encompass all mathematical concepts present in the original statement.\n"
        },
        "20": {
            "formalization": "theory problem_statement imports Complex_Main\nbegin\n\ntheorem smallest_X:\n  fixes X :: nat\n  assumes \"X mod 3 = 2\" and \"X mod 10 = (4 + 5) mod 10\"\n  shows \"X = 14\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the requirements of the natural language statement. While it correctly states that \\(X\\) is a positive integer that is 2 more than a multiple of 3 (i.e., \\(X \\mod 3 = 2\\)), it incorrectly specifies the condition for the units digit. The natural language statement indicates that the units digit of \\(X\\) should be the same as the units digit of a number that is 4 more than a multiple of 5. However, the formal code uses \\(X \\mod 10 = (4 + 5) \\mod 10\\), which simplifies to \\(X \\mod 10 = 9\\). This does not correctly reflect the requirement that the units digit of \\(X\\) matches the units digit of a number that is 4 more than a multiple of 5 (which would be 4, 9, 14, etc.). Therefore, the formalization is incomplete and does not involve all mathematical concepts present in the natural language statement.\n"
        },
        "21": {
            "formalization": "theory sum_modulo_4 imports Complex_Main\nbegin\n\ntheorem sum_modulo_4:\n  shows \"((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12) mod 4) = 2\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code accurately captures the mathematical statement by directly computing the sum of the integers from 1 to 12 and then applying the modulo 4 operation to show that the result is 2. It includes all necessary mathematical concepts: the sum of a series of integers and the modulo operation. The theorem statement clearly reflects the intent of the natural language statement, confirming that the modulo 4 remainder of the sum is indeed 2. Therefore, the formalization meets the aspect of involving all mathematical concepts present in the original statement.\n"
        },
        "22": {
            "formalization": "theory imo_1994_p6 imports\n  Complex_Main\nbegin\n\ntheorem imo_1994_p6:\n  fixes a b c :: real\n  assumes \"a ≤ b\" \"b ≤ c\" \"a + b + c = 2\" \"a * b + b * c + c * a = 1\"\n  shows \"0 ≤ a ∧ a ≤ (1/3) ∧ (1/3) ≤ b ∧ b ≤ 1 ∧ 1 ≤ c ∧ c ≤ (4/3)\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It defines the real numbers \\(a\\), \\(b\\), and \\(c\\) and includes the necessary assumptions: \\(a \\leq b \\leq c\\), \\(a + b + c = 2\\), and \\(ab + bc + ca = 1\\). The conclusion of the theorem correctly states the inequalities for \\(a\\), \\(b\\), and \\(c\\) as required: \\(0 \\leq a \\leq \\frac{1}{3}\\), \\(\\frac{1}{3} \\leq b \\leq 1\\), and \\(1 \\leq c \\leq \\frac{4}{3}\\). Therefore, the formalization meets the aspect of involving all mathematical concepts from the original statement.\n"
        },
        "23": {
            "formalization": "theory amc10_2005_p1 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2005_p1:\n  fixes x :: real\n  assumes \"5 + 5 * 10 = 1.1 * x\"\n  shows \"x = 50\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not accurately capture all the mathematical concepts presented in the natural language statement. Specifically, the statement mentions \"500% of 10,\" which should be represented as \"5 * 10\" in the formal code. However, the formal code uses \"5 * 10\" directly without clarifying that it represents \"500% of 10.\" Additionally, the natural language statement implies a relationship between the two sides of the equation that is not fully expressed in the assumptions. The formalization also lacks an explicit representation of the concept of \"110% of what number,\" which is essential to the problem. Therefore, the formalization is incomplete and does not involve all the necessary mathematical concepts. \n"
        },
        "24": {
            "formalization": "theory remainder_power imports\n  Complex_Main\nbegin\n\ntheorem remainder_power:\n  shows \"5^999999 mod 7 = 6\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL accurately captures the mathematical statement by expressing the problem of finding the remainder when \\(5^{999999}\\) is divided by 7, and it asserts that this remainder is equal to 6. The theorem statement directly corresponds to the natural language question, and it includes all necessary mathematical concepts: exponentiation, modulus operation, and the specific values involved (5, 999999, and 7). Therefore, the formalization meets the aspect of involving all mathematical concepts present in the natural language statement.\n"
        },
        "25": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes t :: real\n  defines \"f t = (2^t - 3*t) * t / (4^t)\"\n  assumes \"t \\<in> real\"\n  shows \"max f t = 1/12\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Type unification failed: Clash of types \"real\" and \"nat\"\n\nType error in application: incompatible operand type\n\nOperator:  (^) 2 :: nat \\<Rightarrow> ??'a\nOperand:   t :: real\n\nCoercion Inference:\n\nLocal coercion insertion on the operand failed:\n\"real\" is not a subtype of \"nat\"\n\nNow trying to infer coercions globally.\n\nCoercion inference failed:\nweak unification of subtype constraints fails\nClash of types \"_ \\<Rightarrow> _\" and \"_ set\"\n\n\nIdentified error on line: 11\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the requirement of finding the maximum value of the function \\( f(t) = \\frac{(2^t - 3t)t}{4^t} \\) for real values of \\( t \\). While it defines the function and states that the maximum value is \\( \\frac{1}{12} \\), it lacks the necessary details to show that this is indeed the maximum value, such as proving that \\( f(t) \\) achieves this maximum and that it is the highest value over all real \\( t \\). The use of \"max f t\" is also ambiguous without a clear definition of what \"max\" refers to in this context. Therefore, the formalization does not involve all mathematical concepts from the natural language statement. \n"
        },
        "26": {
            "formalization": "theory amc10_2006_p1 imports Complex_Main\nbegin\n\ntheorem amc10_2006_p1:\n  fixes A B :: int\n  assumes \"A * B = 10\" and \"A * 3 - 8 * B = -1\"\n  shows \"A * B + B = 12\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It defines the integers \\( A \\) and \\( B \\) and includes the necessary equations that arise from factoring the quadratic expression \\( 10x^2 - x - 24 \\) into the form \\( (Ax - 8)(Bx + 3) \\). The assumptions \\( A * B = 10 \\) and \\( A * 3 - 8 * B = -1 \\) correspond to the conditions derived from the factorization, ensuring that the formalization is complete. The conclusion \\( A * B + B = 12 \\) is also included, which aligns with the requirement to show that this expression equals 12. Thus, all mathematical concepts are present in the formalization.\n"
        },
        "27": {
            "formalization": "theory aime_1997_p5 imports Complex_Main\nbegin\n\ntheorem aime_1997_p5:\n  fixes A B C :: nat\n  assumes \"n = 3^17 + 3^10\"\n      and \"n + 1 ≡ 0 (mod 11)\"\n      and \"n = 1000000 * A + 100000 * B + 10000 * C + 1000 * A + 100 * C + 10 * C + 1 * B\"\n      and \"A ≠ B\" and \"A ≠ C\" and \"B ≠ C\"\n      and \"A mod 2 = 1\" and \"C mod 2 = 1\"\n      and \"B mod 3 ≠ 0\"\n  shows \"100 * A + 10 * B + C = 129\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 14\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It defines \\( n \\) as \\( 3^{17} + 3^{10} \\) and includes the condition that \\( n + 1 \\) is divisible by \\( 11 \\). Furthermore, it expresses \\( n \\) in the specified base \\( 10 \\) format \\( ABCACCBAB \\) using the appropriate coefficients for \\( A \\), \\( B \\), and \\( C \\). The distinctness conditions for \\( A \\), \\( B \\), and \\( C \\) are also included, along with the parity conditions for \\( A \\) and \\( C \\) and the divisibility condition for \\( B \\). Finally, the theorem states that \\( 100A + 10B + C = 129 \\), which aligns with the conclusion of the natural language statement. Thus, all relevant mathematical concepts are present in the formalization. \n"
        },
        "28": {
            "formalization": "theory mod_example imports Complex_Main\nbegin\n\ntheorem mod_example:\n  shows \"54 mod 6 = 0\"\n  by simp\n\nend\n",
            "error_details": "Identified error on line: 7\nError message: Failed to apply initial proof method\\<^here>:\ngoal (1 subgoal):\n 1. 54 mod 6 = 0\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization accurately captures the mathematical statement by directly stating that the remainder of 54 when divided by 6 is 0. The use of the theorem and the simplification method (`by simp`) effectively demonstrates the claim that 54 mod 6 equals 0, which is the essence of the natural language statement. All relevant mathematical concepts, including the operation of modulus and the specific numbers involved, are present in the formal code.\n"
        },
        "29": {
            "formalization": "theory aime_1985_p5 imports Complex_Main\nbegin\n\ntheorem aime_1985_p5:\n  fixes a b :: real\n  assumes \"a^2 * b^3 = 32 / 27\" and \"a / b^3 = 27 / 4\"\n  shows \"a + b = 8 / 3\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines the variables \\(a\\) and \\(b\\) as real numbers, includes the equations \\(a^2b^3 = \\frac{32}{27}\\) and \\(\\frac{a}{b^3} = \\frac{27}{4}\\) as assumptions, and states the conclusion that \\(a + b = \\frac{8}{3}\\). Therefore, all necessary components of the original statement are represented in the formal code.\n"
        },
        "30": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes a b :: real\n  assumes \"a = a_1\" and \"b = b_1\"\n  defines \"f n = (sqrt 3 * a - b, sqrt 3 * b + a)\"\n  assumes \"f 100 = (2, 4)\"\n  shows \"a + b = 1 / (2 ^ 98)\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Not a meta-equality (\\<equiv>)\nThe error(s) above occurred in definition:\n\"f n = (sqrt 3 * a - b, sqrt 3 * b + a)\"\n\nIdentified error on line: 12\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical concepts presented in the natural language statement. Specifically, the formal code defines a function `f` that computes the next point in the sequence based on the current point `(a, b)`, but it does not correctly implement the recursive nature of the sequence for all `n` from 1 to 100. Additionally, the initial conditions for `a_1` and `b_1` are not properly established in the context of the sequence, as the code does not iterate or compute the values leading up to `f(100)`. The assumptions and definitions provided do not encompass the entire sequence's behavior or the necessary calculations to derive `a_1 + b_1` from the given endpoint `(2, 4)`. Thus, the formalization is incomplete and does not involve all mathematical concepts from the original statement.\n"
        },
        "31": {
            "formalization": "theory irreducible_fraction imports\n  Complex_Main\nbegin\n\ntheorem irreducible_fraction:\n  fixes n :: nat\n  shows \"gcd(21*n + 4, 14*n + 3) = 1\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: No type arity prod :: gcd\n\nIdentified error on line: 9\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures the essential mathematical concepts present in the natural language statement. It correctly identifies the fraction \\(\\frac{21n+4}{14n+3}\\) and translates the requirement for it to be irreducible into the condition that the greatest common divisor (gcd) of the numerator and denominator is equal to 1. The use of the variable \\(n\\) as a natural number is also appropriately represented. Therefore, all necessary mathematical concepts from the statement are included in the formalization.\n"
        },
        "32": {
            "formalization": "theory am_gm_inequality imports\n  Complex_Main\nbegin\n\ntheorem am_gm_inequality:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"b ≤ a\"\n  shows \"(a + b) / 2 - sqrt (a * b) ≤ (a - b)^2 / (8 * b)\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It correctly defines the variables \\( a \\) and \\( b \\) as positive real numbers and includes the assumption \\( b \\leq a \\). The theorem statement accurately reflects the inequality that needs to be proven, which is \\( \\frac{a+b}{2} - \\sqrt{ab} \\leq \\frac{(a-b)^2}{8b} \\). Thus, all essential components of the original statement are represented in the formal code.\n"
        },
        "33": {
            "formalization": "theory lcm_gcd imports Complex_Main\nbegin\n\ntheorem lcm_gcd:\n  fixes a b :: nat\n  assumes \"lcm a b = 3720\" and \"gcd a b = 8\" and \"a = 120\"\n  shows \"b = 248\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It correctly defines the least common multiple (lcm) and the greatest common divisor (gcd) of two numbers, specifies one of the numbers (120), and states the conclusion that the other number (b) is 248. The assumptions and the conclusion align with the requirements of the original statement, thus meeting the aspect of involving all mathematical concepts.\n"
        },
        "34": {
            "formalization": "theory inequality imports Complex_Main\nbegin\n\ntheorem inequality:\n  fixes a b :: real\n  shows \"(|a + b|) / (1 + |a + b|) ≤ (|a|) / (1 + |a|) + (|b|) / (1 + |b|)\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 8\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts present in the natural language statement. It correctly defines the theorem for any real numbers \\(a\\) and \\(b\\) and states the inequality involving the absolute values and the specified fractions. The use of the `fixes` keyword indicates that \\(a\\) and \\(b\\) are universally quantified real numbers, which aligns with the natural language statement. The formal code accurately reflects the structure and content of the original statement, ensuring that all necessary components are included.\n"
        },
        "35": {
            "formalization": "theory solve_equation imports Complex_Main\nbegin\n\ntheorem solve_equation:\n  fixes x :: real\n  assumes \"((x - 9) / (x + 1)) = 2\"\n  shows \"x = -11\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It sets up the equation \\(\\frac{x-9}{x+1}=2\\) as an assumption and correctly states that the solution to this equation is \\(x = -11\\). The use of the theorem structure in Isabelle/HOL is appropriate for proving the solution, and the variable \\(x\\) is defined as a real number, which aligns with the context of the problem. The formal code effectively reflects the problem's requirements without omitting any essential concepts.\n"
        },
        "36": {
            "formalization": "theory imo_1997_p6 imports\n  Complex_Main\nbegin\n\ntheorem imo_1997_p6:\n  fixes a :: \"nat \\<Rightarrow> nat \\<Rightarrow> real\" and x :: \"nat \\<Rightarrow> real\"\n  assumes \"a 1 1 > 0\" and \"a 2 2 > 0\" and \"a 3 3 > 0\"\n  and \"\\<forall>i j. (i \\<noteq> j) \\<longrightarrow> a i j < 0\"\n  and \"\\<forall>i. a i 1 + a i 2 + a i 3 > 0\"\n  shows \"x 1 = 0 \\<and> x 2 = 0 \\<and> x 3 = 0\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines a system of equations with three unknowns \\(x_1\\), \\(x_2\\), and \\(x_3\\), and includes the conditions on the coefficients \\(a_{ij}\\) as specified: the diagonal elements being positive, the off-diagonal elements being negative, and the sum of coefficients in each equation being positive. The assumptions in the formal code correspond directly to the conditions outlined in the natural language statement. Therefore, the formalization meets the requirement of involving all mathematical concepts from the original statement.\n"
        },
        "37": {
            "formalization": "theory plumbing_repairs imports Complex_Main\nbegin\n\ntheorem plumbing_repairs:\n  fixes N x :: real\n  assumes \"N + x = 97\" and \"N + 5 * x = 265\"\n  shows \"N + 2 * x = 139\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts presented in the natural language statement. It defines the variables \\(N\\) and \\(x\\) as real numbers, representing the fixed charge and the hourly rate, respectively. The assumptions correctly reflect the conditions given in the problem: \\(N + x = 97\\) for the one-hour job and \\(N + 5x = 265\\) for the five-hour job. The conclusion \\(N + 2x = 139\\) directly corresponds to the question of what Mr. Wrench charges for a two-hour job. Therefore, all relevant mathematical concepts from the natural language statement are included in the formalization.\n"
        },
        "38": {
            "formalization": "theory ac_circuits imports Complex_Main\nbegin\n\ntheorem ac_circuits:\n  fixes I :: complex\n  assumes \"V = 1 + i\" and \"Z = 2 - i\"\n  shows \"I = (1 + i) / (2 - i) = (1/5) + (3/5) * i\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Type unification failed: Clash of types \"complex\" and \"bool\"\n\nType error in application: incompatible operand type\n\nOperator:  (=) (I = (1 + i) / (2 - i)) :: bool \\<Rightarrow> bool\nOperand:   1 / 5 + 3 / 5 * i :: complex\n\nCoercion Inference:\n\nLocal coercion insertion on the operand failed:\n\"complex\" is not a subtype of \"bool\"\n\nNow trying to infer coercions globally.\n\nCoercion inference failed:\nno supremum\n\nCannot fulfil subtype constraints:\n  bool  <:  ??'a   from function application  (=) (I = (1 + i) / (2 - i))\n  ??'a  <:  ??'b   from function application  i\n  ??'a  <:  ??'b   from function application  i\n  ??'a  <:  ??'b   from function application  i\n  ??'a  <:  ??'b   from function application  i\n  ??'a  <:  ??'b   from function application  i\n  ??'a  <:  ??'b   from function application  3 / 5 * i\n  ??'a  <:  ??'b   from function application  5\n  ??'a  <:  ??'b   from function application  3 / 5\n  ??'a  <:  ??'b   from function application  3\n  ??'a  <:  ??'b   from function application  (/) 3\n  ??'a  <:  ??'b   from function application  (*) (3 / 5)\n  ??'a  <:  ??'b   from function application  1 / 5 + 3 / 5 * i\n  ??'a  <:  ??'b   from function application  5\n  ??'a  <:  ??'b   from function application  1 / 5\n  ??'a  <:  ??'b   from function application  (/) 1\n  ??'a  <:  ??'b   from function application  (+) (1 / 5)\n  ??'a  <:  ??'b   from function application\n    (I = (1 + i) / (2 - i)) = 1 / 5 + 3 / 5 * i\n\nIdentified error on line: 9\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts present in the natural language statement. It defines the variables for voltage \\( V \\), current \\( I \\), and impedance \\( Z \\) as complex numbers, which is consistent with their roles in AC circuit analysis. The equation \\( I = \\frac{V}{Z} \\) is correctly expressed, and the specific values for \\( V \\) and \\( Z \\) are provided as assumptions. The conclusion shows the expected result for \\( I \\) as \\( \\frac{1}{5} + \\frac{3}{5}i \\), which aligns with the requirement to demonstrate the calculation. Thus, all relevant concepts are included in the formalization.\n"
        },
        "39": {
            "formalization": "theory amc10_2006_p25 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2006_p25:\n  fixes A :: nat\n  assumes \"A = sum_divisors 500\"\n  shows \"sum_distinct_prime_divisors A = 25\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the essential mathematical concepts from the natural language statement. It defines \\( A \\) as the sum of the positive divisors of \\( 500 \\) using the assumption `A = sum_divisors 500`, which aligns with the statement. Furthermore, it correctly states the goal of showing that the sum of the distinct prime divisors of \\( A \\) equals \\( 25 \\) with `sum_distinct_prime_divisors A = 25`. Thus, all mathematical concepts are present in the formalization.\n"
        },
        "40": {
            "formalization": "theory f_function imports Complex_Main\nbegin\n\nfun f :: \"nat ⇒ nat\" where\n  \"f 2 = 0\" |\n  \"f 3 = Suc 0\" |\n  \"f 9999 = 3333\" |\n  \"f (m + n) = f m + f n + (if (f m + f n + 0) mod 2 = 0 then 0 else 1)\"\n\ntheorem f_function_value:\n  shows \"f 1982 = 660\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 5\nError message: Malformed definition:\nNon-constructor pattern not allowed in sequential mode.\nf 2 = 0\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture all the mathematical concepts presented in the natural language statement. While it defines the function \\( f(n) \\) on positive integers and specifies some values, it does not explicitly ensure that \\( f(n) \\) takes non-negative integer values for all positive integers \\( n \\). Additionally, the condition \\( f(m+n) - f(m) - f(n) = 0 \\text{ or } 1 \\) is represented in a way that may not correctly reflect the original statement, as it uses a specific form involving modulo which could lead to incorrect interpretations. The theorem statement also lacks a proof, indicated by \"sorry,\" which means the formalization is incomplete. Therefore, it does not meet the requirement of involving all mathematical concepts from the natural language statement.\n"
        },
        "41": {
            "formalization": "theory enrollment_problem imports Complex_Main\nbegin\n\ntheorem enrollment_increase:\n  fixes last_year_enrollment :: real\n  assumes \"last_year_enrollment * 1.04 = 598\"\n  shows \"last_year_enrollment = 575\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code captures all the essential mathematical concepts from the natural language statement. It defines a variable for last year's enrollment and uses an assumption to represent the increase in enrollment due to redistricting, specifically stating that this year's enrollment (598 students) is 4% greater than last year's enrollment. The theorem aims to show that last year's enrollment equals 575 students, which aligns perfectly with the conclusion of the natural language statement. Therefore, all relevant concepts are included in the formalization.\n"
        },
        "42": {
            "formalization": "theory inequality_problem imports\n  Complex_Main\nbegin\n\ntheorem inequality_solution:\n  fixes x :: real\n  assumes \"4 * x^2 / ((1 - sqrt (2 * x + 1))^2) < 2 * x + 9\"\n  shows \"(* solution set for x *)\"\n  sorry\n\nend\n",
            "error_details": "Identified error on line: 6\nError message: Inner syntax error\\<^here>\nFailed to parse prop\n\nIdentified error on line: 10\nError message: Bad context for command \"sorry\"\\<^here> -- using reset state\n\n",
            "aspect_evaluation": "Judgement: False\nExplanation: The formalization does not fully capture the mathematical statement as it lacks the explicit identification of the solution set for the variable \\( x \\). While it correctly sets up the inequality and introduces the variable \\( x \\), it does not provide a method or expression to determine the values of \\( x \\) that satisfy the inequality, which is a crucial aspect of the original statement. The placeholder \"(* solution set for x *)\" indicates that the solution is not yet defined, meaning the formalization is incomplete in addressing the requirement of identifying the values of \\( x \\).\n"
        },
        "43": {
            "formalization": "theory amc12a_2005_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2005_p5:\n  fixes n :: nat\n  assumes \"((2*n)^2 + (2*n + 2)^2 + (2*n + 4)^2) = 12296\"\n  shows \"(2*n) * (2*n + 2) * (2*n + 4) div 8 = 32736\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts from the natural language statement. It defines three consecutive positive even numbers in terms of a natural number \\( n \\) and correctly formulates the equation for their squares summing to 12296. Additionally, it shows the requirement to find the product of these numbers divided by 8 and asserts that this product equals 32736. The assumptions and the conclusion in the theorem align with the original statement, indicating that all relevant mathematical concepts are included.\n"
        },
        "44": {
            "formalization": "theory intersection_lines imports Complex_Main\nbegin\n\ntheorem intersection_lines:\n  fixes s t :: real\n  assumes \"s = 9 - 2 * t\" and \"t = 3 * s + 1\"\n  shows \"(s, t) = (1, 4)\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the mathematical concepts presented in the natural language statement. It defines the variables \\(s\\) and \\(t\\) as real numbers and includes the equations representing the lines \\(s = 9 - 2t\\) and \\(t = 3s + 1\\). The theorem states that the intersection point of these lines is \\((s, t) = (1, 4)\\), which aligns with the requirement to show that this point is the intersection. Therefore, all necessary concepts from the natural language statement are included in the formalization.\n"
        },
        "45": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes a b c :: real\n  assumes \"P x = x^3 + a * x^2 + b * x + c\"\n  assumes \"roots P = {cos (2 * pi / 7), cos (4 * pi / 7), cos (6 * pi / 7)}\"\n  shows \"a * b * c = 1 / 32\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization in Isabelle/HOL captures all the essential mathematical concepts presented in the natural language statement. It defines a polynomial \\( P(x) \\) with the specified roots, which are the cosine values of the angles \\( \\frac{2\\pi}{7} \\), \\( \\frac{4\\pi}{7} \\), and \\( \\frac{6\\pi}{7} \\). The variables \\( a \\), \\( b \\), and \\( c \\) are correctly introduced as real numbers, and the relationship \\( a * b * c = \\frac{1}{32} \\) is stated as the conclusion to be proven. The assumptions ensure that the roots are correctly specified, aligning with the roots of the polynomial as described in the natural language statement. Thus, all mathematical concepts are represented in the formalization.\n"
        },
        "46": {
            "formalization": "theory complex_eval imports Complex_Main\nbegin\n\ntheorem complex_eval:\n  shows \"((\\<i> / 2) ^ 2) = - (1 / 4)\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalized code in Isabelle/HOL accurately captures the mathematical concepts presented in the natural language statement. It evaluates the expression \\(\\left(\\frac{i}{2}\\right)^2\\) and asserts that it equals \\(-\\frac{1}{4}\\), which is exactly what the natural language statement requests. The use of the theorem structure and the expression in the code reflects the mathematical operation and its expected result, thus involving all necessary concepts. \n"
        },
        "47": {
            "formalization": "theory mod_computation imports\n  Complex_Main\nbegin\n\ntheorem mod_computation:\n  shows \"29^13 - 5^13 mod 7 = 3\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It correctly states the computation of \\(29^{13} - 5^{13}\\) modulo 7 and asserts that the result is equal to 3. The use of the \"mod\" operator and the equality to 3 are both present, fulfilling the requirements of the original statement. The formal code is structured appropriately, and while it uses \"sorry\" to indicate that the proof is not yet complete, it does not omit any essential concepts from the original statement.\n"
        },
        "48": {
            "formalization": "theory patio_problem imports Complex_Main\nbegin\n\ntheorem patio_diagonal_squared:\n  fixes l w :: real\n  assumes \"l * w = 180\" and \"2 * (l + w) = 54\"\n  shows \"l^2 + w^2 = 369\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It defines the area of the rectangular patio as the product of its length \\( l \\) and width \\( w \\), and it also incorporates the perimeter condition. The theorem aims to show that the sum of the squares of the length and width equals 369, which corresponds to the square of the diagonal of the rectangle. Therefore, all relevant mathematical concepts from the statement are included in the formalization.\n"
        },
        "49": {
            "formalization": "theory example_problem imports Complex_Main\nbegin\n\ntheorem example_problem:\n  fixes y :: real\n  assumes \"sqrt (19 + 3 * y) = 7\"\n  shows \"y = 10\"\n  sorry\n\nend\n",
            "error_details": "",
            "aspect_evaluation": "Judgement: True\nExplanation: The formalization captures all the mathematical concepts present in the natural language statement. It defines a theorem that fixes a variable \\( y \\) of type real and assumes the equation \\( \\sqrt{19 + 3y} = 7 \\). The goal is to show that this leads to the conclusion \\( y = 10 \\). The structure of the formal code aligns with the requirements of the statement, including the equation to solve and the assertion to prove. Therefore, it meets the aspect of involving all necessary mathematical concepts.\n"
        }
    },
    "zero-shot+hcfr": {
        "0": {
            "formalization": "theory test\nimports Main \"~~/src/HOL/Number_Theory/Divisibility\"\nbegin\n\nlemma least_positive_integer:\n  assumes \"n > 0\"\n  shows \"80325 divides (fact n) \\<longleftrightarrow> n \\<ge> 17\"\n  using assms\n  by (simp add: factorial_divides_iff)\n\nlemma least_n:\n  shows \"80325 divides (fact 17) \\<and> (\\<forall>n. n < 17 \\<longrightarrow> \\<not> 80325 divides (fact n))\"\n  by (simp add: factorial_divides_iff)\n\nend\n"
        },
        "1": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma div_11: \"∀n::nat. 11 ∣ (10^n - (-1)^n)\"\nproof (induction n)\n  case 0\n  then show ?case by simp\nnext\n  case (Suc n)\n  then show ?case by (simp add: mod_mult_right mod_add)\nqed\n\nend\n"
        },
        "2": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma congruence_solution:\n  assumes \"3 * n mod 11 = 2\"\n  shows \"n mod 11 = 8\"\nproof -\n  have \"3 * 8 mod 11 = 24 mod 11\"\n    by simp\n  also have \"... = 2\"\n    by simp\n  finally show ?thesis\n    using assms by (simp add: mod_eq_iff)\nqed\n\nend\n"
        },
        "3": {
            "formalization": "theory test\nimports Main\nbegin\n\nfun p :: \"nat ⇒ nat\" where\n  \"p n = n^2 - n + 41\"\n\nlemma common_factor:\n  assumes \"n > 0\"\n  shows \"gcd (p n) (p (n + 1)) > 1 ⟷ n = 41\"\nproof -\n  have \"p (n + 1) = (n + 1)^2 - (n + 1) + 41\"\n    by (simp add: p.simps)\n  then have \"p (n + 1) = n^2 + 2n + 1 - n - 1 + 41\"\n    by simp\n  also have \"... = n^2 + n + 41\"\n    by simp\n  finally have \"p (n + 1) = p n + n + 1\" by simp\n  show ?thesis\n  proof (cases \"n = 41\")\n    case True\n    then show ?thesis by simp\n  next\n    case False\n    then have \"gcd (p n) (p (n + 1)) = gcd (p n) (p n + n + 1)\"\n      by simp\n    also have \"... = gcd (p n) (n + 1)\"\n      by (simp add: gcd_add_right)\n    finally show ?thesis using False by simp\n  qed\nqed\n\nend\n"
        },
        "4": {
            "formalization": "theory test\n  imports \"HOL.Real\"\nbegin\n\nlemma min_value:\n  fixes x :: real\n  shows \"x^2 - 14 * x + 3 = (x - 7)^2 - 49 + 3\"\n  by (simp add: algebra_simps)\n\nlemma minimum_at_7:\n  shows \"min x. (x^2 - 14 * x + 3) = 7\"\n  using min_value by (metis)\n\nend\n"
        },
        "5": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\nlemma sec_tan_csc_cot:\n  assumes \"sec x + tan x = 22 / 7\"\n  shows \"∃m n. csc x + cot x = m / n ∧ coprime m n\"\nproof -\n  obtain m n where \"csc x + cot x = m / n\" and \"coprime m n\"\n    using assms by (metis) \n  thus \"∃m n. csc x + cot x = m / n ∧ coprime m n\" by blast\nqed\n\nend\n"
        },
        "6": {
            "formalization": "theory test\n  imports \"Real\"\nbegin\n\nlemma integer_values: \"card {x. x ∈ {.. 3 * π} ∪ {-3 * π ..} ∧ |x| < 3 * π} = 19\"\n  by (simp add: card_of_interval)\n\nend\n"
        },
        "7": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma sum_of_roots:\n  assumes \"(x + 3)^2 = 121\"\n  shows \"let a = x + 3 in (a = 11 ∨ a = -11) ⟹ (x = a - 3) ⟹ (x + x = -6)\"\n  using assms by auto\n\nend\n"
        },
        "8": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma expand_product: \"(x + 1)^2 * x = x^3 + 2 * x^2 + x\"\n  by (simp add: power2_eq_square)\n\nend\n"
        },
        "9": {
            "formalization": "theory test\n  imports \"HOL.Number_Theory.Prime\"\nbegin\n\nlemma prime_divides_a_p_minus_a:\n  fixes p :: nat and a :: nat\n  assumes \"prime p\" \"0 < a\"\n  shows \"p dvd (a^p - a)\"\n  using assms\n  by (metis (no_types, lifting) dvd_def prime_dvd_pow)\n\nend\n"
        },
        "10": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma units_digit_sum_squares:\n  shows \"(\\<Sum>n::nat. (n + 1)^2) mod 10 = 5\"\nproof -\n  have \"(\\<Sum>n = 0..8. (n + 1)^2) = 285\" by simp\n  thus ?thesis by simp\nqed\n\nend\n"
        },
        "11": {
            "formalization": "theory test\nimports Main\nbegin\n\n  definition A :: nat where \"A = 1\"\n  definition B :: nat where \"B = 2\"\n  definition C :: nat where \"C = 5\"\n\n  lemma distinct_digits: \"A ≠ B ∧ A ≠ C ∧ B ≠ C\"\n    by (simp add: A_def B_def C_def)\n\n  lemma equations: \"A + B = C ∧ (10 * A + A) - B = 2 * C ∧ C * B = (10 * A + A) + A\"\n    by (simp add: A_def B_def C_def)\n\n  lemma sum: \"A + B + C = 8\"\n    by (simp add: A_def B_def C_def)\n\nend\n"
        },
        "12": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma product_of_odd_integers_less_than_10000:\n  \"(\\<Prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\nproof -\n  have \"(\\<Prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\n    by (simp add: factorial_def)\n  thus ?thesis by simp\nqed\n\nend\n"
        },
        "13": {
            "formalization": "theory test\nimports Real\nbegin\n\nlemma solution_set_integer_count:\n  shows \"card {x :: int. abs(x - 2) ≤ 5.6} = 11\"\n  by (simp add: abs_le_iff)\n\nend\n"
        },
        "14": {
            "formalization": "theory test\n  imports \"HOL.Real\"\nbegin\n\nlemma triangle_inequality:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ≥ 0\"\nproof -\n  have \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) = 0\"\n    if \"a = b\" \"b = c\" \"c = a\" for a b c :: real\n    using that by auto\n  then show ?thesis\n    using assms by (simp add: real_ge_def)\nqed\n\nend\n"
        },
        "15": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma example:\n  assumes \"3 * a + b + c = -3\"\n    and \"a + 3 * b + c = 9\"\n    and \"a + b + 3 * c = 19\"\n  shows \"a * b * c = -56\"\nproof -\n  obtain a b c where \"3 * a + b + c = -3\" \"a + 3 * b + c = 9\" \"a + b + 3 * c = 19\"\n    using assms by auto\n  then have \"a = 1\" \"b = -4\" \"c = 3\" by (simp_all add: algebra_simps)\n  then show ?thesis by simp\nqed\n\nend\n"
        },
        "16": {
            "formalization": "theory test\nimports Main\nbegin\n\nfun D :: \"nat ⇒ nat\" where\n  \"D 0 = 0\" |\n  \"D 1 = 0\" |\n  \"D 2 = 1\" |\n  \"D n = D (n - 1) + D (n - 3)\" for n :: nat\n\ndefinition parity :: \"nat ⇒ bool\" where\n  \"parity n ≡ D n mod 2 = 1\"\n\nlemma parity_triple: \"parity 2021 = False ∧ parity 2022 = True ∧ parity 2023 = False\"\n  by (simp add: parity_def)\n\nend\n"
        },
        "17": {
            "formalization": "theory test\nimports Main\nbegin\n\n  definition h :: \"nat ⇒ nat\" where \"h x = f_inv x\"\n\n  lemma h_2: \"h 2 = 10\"\n  lemma h_10: \"h 10 = 1\"\n  lemma h_1: \"h 1 = 2\"\n\n  lemma f_f_10: \"f (f 10) = 1\"\n  proof -\n    have \"h (f 10) = 2\" using h_1 by (simp add: h_def)\n    then have \"f (h (f 10)) = f 2\" by (simp add: f_inv_def)\n    then show ?thesis using h_2 by (simp add: h_def)\n  qed\n\nend\n"
        },
        "18": {
            "formalization": "theory test\nimports Main \"HOL/Number_Theory/Divisors\"\nbegin\n\ndefinition factorial_product :: \"nat\" where\n  \"factorial_product = (1! * 2! * 3! * 4! * 5! * 6! * 7! * 8! * 9!)\"\n\nlemma perfect_squares_divisors_count:\n  \"count_perfect_squares_divisors factorial_product = 672\"\n  by (simp add: factorial_product_def)\n\nend\n"
        },
        "19": {
            "formalization": "theory test\n  imports Main\nbegin\n\ndefinition I :: nat where \"I = 1\"\ndefinition M :: nat where \"M = 7\"\ndefinition O :: nat where \"O = 287\"\n\nlemma distinct_positive_integers: \"I ≠ M ∧ I ≠ O ∧ M ≠ O\"\n  by (simp add: I_def M_def O_def)\n\nlemma product: \"I * M * O = 2001\"\n  by (simp add: I_def M_def O_def)\n\nlemma sum: \"I + M + O = 1 + 7 + 287\"\n  by (simp add: I_def M_def O_def)\n\nlemma largest_sum: \"I + M + O = 295\"\n  by (simp add: sum)\n\nend\n"
        },
        "20": {
            "formalization": "theory test\nimports Main\nbegin\n\ndefinition X :: nat where\n  \"X = (let m = 3 * n + 2 in m + (if m mod 10 = (4 + 4) mod 10 then 0 else 1))\"\n\nlemma smallest_X: \"X = 14\"\n  unfolding X_def\n  by (metis mod_eq_0_iff_dvd)\n\nend\n"
        },
        "21": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma modulo_4_remainder_sum: \"((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12) mod 4) = 2\"\n  by (simp add: mod_add_eq)\n\nend\n"
        },
        "22": {
            "formalization": "theory test\n  imports \"HOL/Analysis/Real\"\nbegin\n\nlemma real_numbers_bounds:\n  fixes a b c :: real\n  assumes \"a ≤ b\" \"b ≤ c\" \"a + b + c = 2\" \"a * b + b * c + c * a = 1\"\n  shows \"0 ≤ a ∧ a ≤ (1/3) ∧ (1/3) ≤ b ∧ b ≤ 1 ∧ 1 ≤ c ∧ c ≤ (4/3)\"\n  \nend\n"
        },
        "23": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma five_plus_500_percent_of_10_equals_110_percent_of_x:\n  assumes \"x = 50\"\n  shows \"5 + (500 / 100) * 10 = (110 / 100) * x\"\n  using assms\n  by simp\n\nend\n"
        },
        "24": {
            "formalization": "theory test\n  imports \"HOL.Num\"\nbegin\n\nlemma remainder_5_power_999999_mod_7: \"5 ^ 999999 mod 7 = 6\"\nproof -\n  have \"5 ^ 999999 mod 7 = (5 mod 7) ^ 999999 mod 7\"\n    by (simp add: mod_mult_eq)\n  also have \"... = 5 ^ 999999 mod 7\"\n    by (simp add: mod_eq_0_iff)\n  finally show \"5 ^ 999999 mod 7 = 6\"\n    by (simp add: mod_add_eq)\nqed\n\nend\n"
        },
        "25": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\n  definition f :: \"real ⇒ real\" where\n    \"f t = (2^t - 3*t) * t / 4^t\"\n\n  lemma max_value: \"∃t. f t = 1/12\"\n    by (simp add: f_def)\n\nend\n"
        },
        "26": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma factorization_example:\n  assumes \"A * B = 10\" \"A * 3 + B * (-8) = -1\" \"A ∈ ℤ\" \"B ∈ ℤ\"\n  shows \"A * B + B = 12\"\nproof -\n  have \"A * B = 10\" using assms(1) by simp\n  have \"A * 3 + B * (-8) = -1\" using assms(2) by simp\n  then have \"B = (A * 3 + 1) / (-8)\" using algebra_simps by auto\n  then show ?thesis using `A * B = 10` by (metis)\nqed\n\nend\n"
        },
        "27": {
            "formalization": "theory test\nimports Main\nbegin\n\ndefinition n :: nat where\n  \"n = 3^17 + 3^10\"\n\nlemma \"11 dvd (n + 1)\"\n  unfolding n_def\n  by (simp add: power_add)\n\ndefinition A :: nat where\n  \"A = 1\"  (* Example value, to be replaced with actual distinct digit *)\n  \ndefinition B :: nat where\n  \"B = 2\"  (* Example value, to be replaced with actual distinct digit *)\n\ndefinition C :: nat where\n  \"C = 9\"  (* Example value, to be replaced with actual distinct digit *)\n\nlemma distinct_digits: \"A ≠ B ∧ A ≠ C ∧ B ≠ C\"\n  unfolding A_def B_def C_def\n  by auto\n\nlemma odd_conditions: \"odd A ∧ odd C\"\n  unfolding A_def C_def\n  by auto\n\nlemma not_divisible_by_3: \"B mod 3 ≠ 0\"\n  unfolding B_def\n  by auto\n\nlemma find_100A_10B_C: \"100 * A + 10 * B + C = 129\"\n  unfolding A_def B_def C_def\n  by simp\n\nend\n"
        },
        "28": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma remainder_54_mod_6: \"54 mod 6 = 0\"\n  by (simp add: mod_eq_0_iff_dvd) (simp add: dvd_def)\n\nend\n"
        },
        "29": {
            "formalization": "theory test\n  imports Real\nbegin\n\nlemma example:\n  assumes \"a ∈ ℝ\" \"b ∈ ℝ\" \"a^2 * b^3 = 32 / 27\" \"a / b^3 = 27 / 4\"\n  shows \"a + b = 8 / 3\"\n  using assms\n  by (simp add: field_simps)\n\nend\n"
        },
        "30": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\n  definition transformation :: \"real × real ⇒ real × real\" where\n    \"transformation (a, b) = (\\<sqrt>3 * a - b, \\<sqrt>3 * b + a)\"\n\n  fun sequence :: \"nat ⇒ real × real\" where\n    \"sequence n = (if n = 100 then (2, 4) else transformation (sequence (n + 1)))\"\n\n  lemma a1_b1_sum: \"sequence 1 = (1 / 2 ^ 98, -1 / 2 ^ 99) ⟹ fst (sequence 1) + snd (sequence 1) = 0\"\n    by (simp add: sequence.simps transformation_def)\n\nend\n"
        },
        "31": {
            "formalization": "theory test\n  imports Main \"~~/src/HOL/Number_Theory/Divisibility\"\nbegin\n\nlemma irreducible_fraction: \"n ∈ ℕ ⟹ gcd (21 * n + 4) (14 * n + 3) = 1\"\n  by (simp add: gcd.commute)\n\nend\n"
        },
        "32": {
            "formalization": "theory test\n  imports Real\nbegin\n\nlemma am_gm: \"0 < b ⟹ b ≤ a ⟹ (a + b) / 2 - sqrt (a * b) ≤ (a - b) ^ 2 / (8 * b)\"\n  by (simp add: sqrt_le_iff)\n\nend\n"
        },
        "33": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma lcm_gcd_example:\n  assumes \"lcm 120 x = 3720\" and \"gcd 120 x = 8\"\n  shows \"x = 248\"\nproof -\n  have \"lcm 120 x * gcd 120 x = 120 * x\" using lcm_gcd[of 120 x] by (simp add: assms)\n  then have \"3720 * 8 = 120 * x\" using assms by simp\n  then have \"x = (3720 * 8) div 120\" by (simp add: divide_eq_iff)\n  also have \"3720 * 8 = 29760\" by simp\n  then have \"x = 29760 div 120\" by (simp add: algebra_simps)\n  also have \"29760 div 120 = 248\" by simp\n  finally show ?thesis by simp\nqed\n\nend\n"
        },
        "34": {
            "formalization": "theory test\n  imports \"HOL.Real\"\nbegin\n\nlemma real_inequality: \"∀a b::real. (|a + b|) / (1 + |a + b|) ≤ (|a|) / (1 + |a|) + (|b|) / (1 + |b|)\"\n  by (auto simp: abs_add)\n\nend\n"
        },
        "35": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma solve_equation:\n  assumes \"x - 9 = 2 * (x + 1)\"\n  shows \"x = -11\"\nproof -\n  have \"x - 9 = 2 * (x + 1)\" using assms by simp\n  then have \"x - 9 = 2 * x + 2\" by simp\n  then have \"x - 2 * x = 11\" by (simp add: algebra_simps)\n  then have \"-x = 11\" by simp\n  thus ?thesis by simp\nqed\n\nend\n"
        },
        "36": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\n  definition a11 :: \"real\" where \"a11 = 1\"  (* Example positive coefficient *)\n  definition a22 :: \"real\" where \"a22 = 1\"  (* Example positive coefficient *)\n  definition a33 :: \"real\" where \"a33 = 1\"  (* Example positive coefficient *)\n\n  definition a12 :: \"real\" where \"a12 = -1\" (* Example negative coefficient *)\n  definition a13 :: \"real\" where \"a13 = -1\" (* Example negative coefficient *)\n  definition a21 :: \"real\" where \"a21 = -1\" (* Example negative coefficient *)\n  definition a23 :: \"real\" where \"a23 = -1\" (* Example negative coefficient *)\n  definition a31 :: \"real\" where \"a31 = -1\" (* Example negative coefficient *)\n  definition a32 :: \"real\" where \"a32 = -1\" (* Example negative coefficient *)\n\n  lemma unique_solution:\n    assumes \"a11 > 0\" \"a22 > 0\" \"a33 > 0\"\n    and \"a12 < 0\" \"a13 < 0\" \"a21 < 0\" \"a23 < 0\" \"a31 < 0\" \"a32 < 0\"\n    and \"a11 + a12 + a13 > 0\" \"a21 + a22 + a23 > 0\" \"a31 + a32 + a33 > 0\"\n    shows \"x1 = 0 ∧ x2 = 0 ∧ x3 = 0\"\n  sorry\n\nend\n"
        },
        "37": {
            "formalization": "theory test\nimports Main\nbegin\n\n  definition charge :: \"nat ⇒ nat ⇒ nat\" where\n    \"charge N x = N + x\"\n\n  lemma charge_two_hour_job:\n    assumes \"charge N x = 97\" and \"charge N (5 * x) = 265\"\n    shows \"charge N (2 * x) = 139\"\n  proof -\n    have \"N + x = 97\" using assms(1) by (simp add: charge_def)\n    have \"N + 5 * x = 265\" using assms(2) by (simp add: charge_def)\n    then have \"5 * x = 265 - N\" by (simp add: charge_def)\n    then have \"x = (265 - N) div 5\" by (simp add: div_mult_eq)\n    then have \"N + 2 * x = N + 2 * ((265 - N) div 5)\" by (simp add: charge_def)\n    also have \"... = N + (530 - 2 * N) div 5\" by (simp add: algebra_simps)\n    also have \"... = (5 * N + 530 - 2 * N) div 5\" by (simp add: algebra_simps)\n    also have \"... = (3 * N + 530) div 5\" by (simp add: algebra_simps)\n    finally show ?thesis using `N + x = 97` by (simp add: algebra_simps)\n  qed\n\nend\n"
        },
        "38": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\nlemma find_current:\n  assumes \"V = 1 + i\" \n  and \"Z = 2 - i\"\n  shows \"I = (1 / 5) + (3 / 5) * i\"\n  using assms(1) assms(2)\n  apply (subst assms(1))\n  apply (subst assms(2))\n  apply (simp add: algebra_simps)\n  done\n\nend\n"
        },
        "39": {
            "formalization": "theory test\nimports \"HOL/Number_Theory/Divisors\"\nbegin\n\nlemma sum_of_prime_divisors_of_sum_of_divisors_500:\n  shows \"sum_of_prime_divisors (sum_of_divisors 500) = 25\"\n  by (simp add: sum_of_divisors_def sum_of_prime_divisors_def)\n\nend\n"
        },
        "40": {
            "formalization": "theory test\nimports Main\nbegin\n\n  fun f :: \"nat ⇒ nat\" where\n    \"f 2 = 0\" |\n    \"f 3 = 1\" |  (* f(3) > 0 *)\n    \"f 9999 = 3333\" |\n    \"f (m + n) = f m + f n + (if f m + f n < f (m + n) then 1 else 0)\"\n\n  lemma f_1982: \"f 1982 = 660\"\n  by (simp add: f.simps)\n\nend\n"
        },
        "41": {
            "formalization": "theory test\n  imports Main\nbegin\n\n  definition last_year_enrollment :: real where\n    \"last_year_enrollment = 598 / (1 + 0.04)\"\n\n  lemma last_year_enrollment_value: \"last_year_enrollment = 575\"\n  proof -\n    have \"last_year_enrollment = 598 / 1.04\" by (simp add: last_year_enrollment_def)\n    also have \"... = 575\" by (simp add: field_simps)\n    finally show ?thesis .\n  qed\n\nend\n"
        },
        "42": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma inequality_example:\n  assumes \"1 - sqrt (2 * x + 1) > 0\"\n  shows \"4 * x^2 < (2 * x + 9) * (1 - sqrt (2 * x + 1))^2\"\nproof -\n  have \"1 - sqrt (2 * x + 1) > 0\" using assms by simp\n  then show ?thesis using field_simps by (simp add: field_simps)\nqed\n\nend\n"
        },
        "43": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma sum_of_squares_even_numbers:\n  assumes \"x > 0\" and \"even x\"\n  shows \"((x^2) + ((x + 2)^2) + ((x + 4)^2)) = 12296 ⟹ (x * (x + 2) * (x + 4)) div 8 = 32736\"\nproof -\n  have \"x^2 + (x + 2)^2 + (x + 4)^2 = x^2 + (x^2 + 4 * x + 4) + (x^2 + 8 * x + 16)\"\n    by simp\n  then have \"3 * x^2 + 12 * x + 20 = 12296\"\n    by simp\n  then have \"3 * x^2 + 12 * x - 12276 = 0\"\n    by simp\n  then obtain x' where \"x' = (12 + sqrt(12^2 + 4 * 3 * 12276)) / (2 * 3)\" \n    by (metis)\n  then have \"x' = 38\" \n    by simp\n  then have \"x * (x + 2) * (x + 4) = 38 * 40 * 42\"\n    by (simp add: `x' = 38`)\n  then show ?thesis\n    by (simp add: divide_simps)\nqed\n\nend\n"
        },
        "44": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\n  definition s :: \"real\" where \"s = 1\"\n  definition t :: \"real\" where \"t = 4\"\n\n  lemma intersection: \"s = 9 - 2 * t ∧ t = 3 * s + 1\"\n  proof -\n    have \"s = 1\" and \"t = 4\" by (simp add: s_def t_def)\n    thus ?thesis\n      by (simp add: s_def t_def)\n  qed\n\nend\n"
        },
        "45": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\nlemma roots_cosine:\n  assumes \"P = (λx. x^3 + a * x^2 + b * x + c)\"\n  shows \"P (cos (2 * π / 7)) = 0 ∧ P (cos (4 * π / 7)) = 0 ∧ P (cos (6 * π / 7)) = 0\"\n  and \"abc = 1 / 32\"\n\nend\n"
        },
        "46": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\nlemma square_of_i_div_2: \"(\\<frac> i 2) ^ 2 = - (\\<frac> 1 4)\"\n  by (simp add: complex_div_def power2_eq_square)\n\nend\n"
        },
        "47": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma compute_modulo: \"29^13 - 5^13 ≡ 3 (mod 7)\"\n  by (simp add: mod_eq_0_iff_dvd)\n\nend\n"
        },
        "48": {
            "formalization": "theory test\n  imports Main\nbegin\n\n  definition area :: \"real ⇒ real ⇒ real\" where\n    \"area l w = l * w\"\n\n  definition perimeter :: \"real ⇒ real ⇒ real\" where\n    \"perimeter l w = 2 * (l + w)\"\n\n  lemma diagonal_squared:\n    assumes \"area l w = 180\" and \"perimeter l w = 54\"\n    shows \"l^2 + w^2 = 369\"\n  proof -\n    from assms(1) have \"l * w = 180\" by (simp add: area_def)\n    from assms(2) have \"l + w = 27\" by (simp add: perimeter_def)\n    have \"l^2 + w^2 = (l + w)^2 - 2 * (l * w)\" \n      by (metis (no_types, lifting) `l + w = 27` `l * w = 180` algebra_simps)\n    then show ?thesis using `l + w = 27` `l * w = 180` by auto\n  qed\n\nend\n"
        },
        "49": {
            "formalization": "theory test\nimports Main\nbegin\n\nlemma sqrt_example: \"sqrt (19 + 3 * 10) = 7\"\n  by (simp add: sqrt_nonneg)\n\nend\n"
        }
    },
    "3-shot+hcfr": {
        "0": {
            "formalization": "theory test\nimports\n  Complex_Main\nbegin\n\ntheorem amc12a_2009_p4:\n  fixes n :: nat\n  assumes \"80325 divides n!\"\n  shows \"n = 17\"\n  sorry\n\nend\n"
        },
        "1": {
            "formalization": "theory divisibility_theorem imports\n  Complex_Main\nbegin\n\ntheorem divisibility_by_11:\n  fixes n :: nat\n  shows \"11 dvd (10^n - (-1)^n)\"\n  sorry\n\nend\n"
        },
        "2": {
            "formalization": "theory congruence_example imports\n  Complex_Main\nbegin\n\ntheorem congruence_solution:\n  fixes n :: nat\n  assumes \"3 * n mod 11 = 2\"\n  shows \"n mod 11 = 8\"\n  sorry\n\nend\n"
        },
        "3": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ndefinition p :: \"nat ⇒ nat\" where\n  \"p n ≡ n^2 - n + 41\"\n\ntheorem euler_polynomial:\n  fixes n :: nat\n  assumes \"∃ n. gcd (p n) (p (n + 1)) > 1\"\n  shows \"n = 41\"\n  sorry\n\nend\n"
        },
        "4": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem minimum_value:\n  fixes x :: real\n  shows \"x = 7\"\n  using real_of_nat_eq_iff[of 7] \n  have \"x^2 - 14*x + 3 = (x - 7)^2 - 49 + 3\"\n    by (simp add: algebra_simps)\n  then show \"True\" by auto\n\nend\n"
        },
        "5": {
            "formalization": "theory amc10_2009_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2009_p5:\n  fixes x :: real\n  assumes \"sec x + tan x = 22 / 7\"\n  shows \"csc x + cot x = 44 / 7\"\n  sorry\n\nend\n"
        },
        "6": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem integer_values:\n  fixes x :: real\n  assumes \"abs x < 3 * pi\"\n  shows \"x \\<in> { -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }\"\nproof -\n  have \"x < 3 * pi\" and \"x > -3 * pi\" using assms by (simp_all add: abs_def)\n  then have \"-3 * pi < x \\<and> x < 3 * pi\" by auto\n  then have \"x \\<in> { -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }\" \n    by auto\n  thus ?thesis by auto\nqed\n\nend\n"
        },
        "7": {
            "formalization": "theory amc12a_2008_p5 imports Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes x :: real\n  assumes \"(x + 3)^2 = 121\"\n  shows \"x + x = -6\"\n  sorry\n\nend\n"
        },
        "8": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem polynomial_expansion:\n  shows \"((x + 1)^2) * x = x^3 + 2 * x^2 + x\"\n  by (simp add: algebra_simps)\n\nend\n"
        },
        "9": {
            "formalization": "theory prime_divides imports\n  Complex_Main\nbegin\n\ntheorem prime_divides:\n  fixes p :: nat and a :: nat\n  assumes \"prime p\" and \"a > 0\"\n  shows \"p dvd (a^p - a)\"\n  sorry\n\nend\n"
        },
        "10": {
            "formalization": "theory test\nimports\n  Complex_Main\nbegin\n\ntheorem units_digit_sum_of_squares:\n  shows \"(\\<Sum>n=1..9. n^2) mod 10 = 5\"\nproof -\n  have \"(\\<Sum>n=1..9. n^2) = 1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2\"\n    by (simp add: sum.power2)\n  also have \"... = 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81\"\n    by simp\n  finally have \"(\\<Sum>n=1..9. n^2) = 285\" by simp\n  thus ?thesis by simp\nqed\n\nend\n"
        },
        "11": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes A B C :: nat\n  assumes \"A + B = C\"\n      and \"10 * A + A - B = 2 * C\"\n      and \"C * B = 10 * A + A + A\"\n      and \"A > 0\" and \"B > 0\" and \"C > 0\" and \"A \\<noteq> B\" and \"B \\<noteq> C\" and \"A \\<noteq> C\"\n  shows \"A + B + C = 8\"\n  sorry\n\nend\n"
        },
        "12": {
            "formalization": "theory test\nimports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  shows \"(\\<prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\n  by (simp add: factorial_odd_product)\n\nend\n"
        },
        "13": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem inequality_solution:\n  fixes x :: real\n  assumes \"abs (x - 2) ≤ 5.6\"\n  shows \"card {n :: int. 2 - 5.6 ≤ real n ∧ real n ≤ 2 + 5.6} = 11\"\n  using assms\n  apply (auto simp add: card_int_iff)\n  done\n\nend\n"
        },
        "14": {
            "formalization": "theory triangle_inequality imports\n  Complex_Main\nbegin\n\ntheorem triangle_inequality:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ≥ 0\"\n  sorry\n\nend\n"
        },
        "15": {
            "formalization": "theory system_of_equations imports Complex_Main\nbegin\n\ntheorem system_of_equations:\n  fixes a b c :: real\n  assumes \"3*a + b + c = -3\"\n      and \"a + 3*b + c = 9\"\n      and \"a + b + 3*c = 19\"\n  shows \"a * b * c = -56\"\n  sorry\n\nend\n"
        },
        "16": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\nfun D :: \"nat ⇒ nat\" where\n  \"D 0 = 0\" |\n  \"D 1 = 0\" |\n  \"D 2 = 1\" |\n  \"D n = D (n - 1) + D (n - 3) ∧ n ≥ 3\"\n\ntheorem amc12a_2008_p5:\n  shows \"D 2021 mod 2 = 0 ∧ D 2022 mod 2 = 1 ∧ D 2023 mod 2 = 0\"\n  sorry\n\nend\n"
        },
        "17": {
            "formalization": "theory test\nimports\n  Complex_Main\nbegin\n\ntheorem functional_inverse:\n  fixes f h :: \"real ⇒ real\"\n  assumes \"h = f inverse\"\n  and \"h 2 = 10\"\n  and \"h 10 = 1\"\n  and \"h 1 = 2\"\n  shows \"f (f 10) = 1\"\n  by (metis assms(1) assms(2) assms(3) assms(4) inverse_f_f)\n\nend\n"
        },
        "18": {
            "formalization": "theory amc10_2006_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2006_p5:\n  fixes n :: nat\n  assumes \"n = 9\"\n  shows \"count_perfect_squares (prod_factorials n) = 672\"\n  sorry\n\nend\n"
        },
        "19": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ntheorem amc12a_2001_p5:\n  fixes I M O :: nat\n  assumes \"I * M * O = 2001\" and \"I \\<noteq> M\" and \"M \\<noteq> O\" and \"I \\<noteq> O\"\n  shows \"I + M + O = 671\"\n  sorry\n\nend\n"
        },
        "20": {
            "formalization": "theory problem_statement imports Complex_Main\nbegin\n\ntheorem smallest_X:\n  fixes X :: nat\n  assumes \"X mod 3 = 2\" and \"X mod 10 = (4 + 5) mod 10\"\n  shows \"X = 14\"\n  sorry\n\nend\n"
        },
        "21": {
            "formalization": "theory sum_modulo_4 imports Complex_Main\nbegin\n\ntheorem sum_modulo_4:\n  shows \"((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12) mod 4) = 2\"\n  sorry\n\nend\n"
        },
        "22": {
            "formalization": "theory imo_1994_p6 imports\n  Complex_Main\nbegin\n\ntheorem imo_1994_p6:\n  fixes a b c :: real\n  assumes \"a ≤ b\" \"b ≤ c\" \"a + b + c = 2\" \"a * b + b * c + c * a = 1\"\n  shows \"0 ≤ a ∧ a ≤ (1/3) ∧ (1/3) ≤ b ∧ b ≤ 1 ∧ 1 ≤ c ∧ c ≤ (4/3)\"\n  sorry\n\nend\n"
        },
        "23": {
            "formalization": "theory amc10_2005_p1 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2005_p1:\n  fixes x :: real\n  assumes \"5 + 5 * 10 = 1.1 * x\"\n  shows \"x = 50\"\n  sorry\n\nend\n"
        },
        "24": {
            "formalization": "theory remainder_power imports\n  Complex_Main\nbegin\n\ntheorem remainder_power:\n  shows \"5^999999 mod 7 = 6\"\n  sorry\n\nend\n"
        },
        "25": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes t :: real\n  defines \"f t = (2^t - 3*t) * t / (4^t)\"\n  assumes \"t \\<in> real\"\n  shows \"max f t = 1/12\"\n  using real_of_nat_def by (simp add: f_def)\n\nend\n"
        },
        "26": {
            "formalization": "theory amc10_2006_p1 imports Complex_Main\nbegin\n\ntheorem amc10_2006_p1:\n  fixes A B :: int\n  assumes \"A * B = 10\" and \"A * 3 - 8 * B = -1\"\n  shows \"A * B + B = 12\"\n  sorry\n\nend\n"
        },
        "27": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem aime_1997_p5:\n  fixes A B C :: nat\n  assumes \"n = 3^17 + 3^10\"\n      and \"n + 1 ≡ 0 (mod 11)\"\n      and \"n = 1000000 * A + 100000 * B + 10000 * C + 1000 * A + 100 * C + 10 * C + B\"\n      and \"A ≠ B\" and \"A ≠ C\" and \"B ≠ C\"\n      and \"A mod 2 = 1\" and \"C mod 2 = 1\"\n      and \"B mod 3 ≠ 0\"\n  shows \"100 * A + 10 * B + C = 129\"\n  sorry\n\nend\n"
        },
        "28": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem mod_example:\n  shows \"54 mod 6 = 0\"\n  by (simp add: mod_eq_0_iff)\n\nend\n"
        },
        "29": {
            "formalization": "theory aime_1985_p5 imports Complex_Main\nbegin\n\ntheorem aime_1985_p5:\n  fixes a b :: real\n  assumes \"a^2 * b^3 = 32 / 27\" and \"a / b^3 = 27 / 4\"\n  shows \"a + b = 8 / 3\"\n  sorry\n\nend\n"
        },
        "30": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes a b :: real\n  assumes \"a = a_1\" and \"b = b_1\"\n  defines f where \"f n = (sqrt 3 * a - b, sqrt 3 * b + a)\"\n  assumes \"f 100 = (2, 4)\"\n  shows \"a + b = 1 / (2 ^ 98)\"\n  sorry\n\nend\n"
        },
        "31": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ntheorem irreducible_fraction:\n  fixes n :: nat\n  shows \"gcd(21 * n + 4, 14 * n + 3) = 1\"\n  sorry\n\nend\n"
        },
        "32": {
            "formalization": "theory am_gm_inequality imports\n  Complex_Main\nbegin\n\ntheorem am_gm_inequality:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"b ≤ a\"\n  shows \"(a + b) / 2 - sqrt (a * b) ≤ (a - b)^2 / (8 * b)\"\n  sorry\n\nend\n"
        },
        "33": {
            "formalization": "theory lcm_gcd imports Complex_Main\nbegin\n\ntheorem lcm_gcd:\n  fixes a b :: nat\n  assumes \"lcm a b = 3720\" and \"gcd a b = 8\" and \"a = 120\"\n  shows \"b = 248\"\n  sorry\n\nend\n"
        },
        "34": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ntheorem inequality:\n  fixes a b :: real\n  shows \"(|a + b|) / (1 + |a + b|) ≤ (|a|) / (1 + |a|) + (|b|) / (1 + |b|)\"\n  by (simp add: real_abs_triangle_ineq)\n\nend\n"
        },
        "35": {
            "formalization": "theory solve_equation imports Complex_Main\nbegin\n\ntheorem solve_equation:\n  fixes x :: real\n  assumes \"((x - 9) / (x + 1)) = 2\"\n  shows \"x = -11\"\n  sorry\n\nend\n"
        },
        "36": {
            "formalization": "theory imo_1997_p6 imports\n  Complex_Main\nbegin\n\ntheorem imo_1997_p6:\n  fixes a :: \"nat \\<Rightarrow> nat \\<Rightarrow> real\" and x :: \"nat \\<Rightarrow> real\"\n  assumes \"a 1 1 > 0\" and \"a 2 2 > 0\" and \"a 3 3 > 0\"\n  and \"\\<forall>i j. (i \\<noteq> j) \\<longrightarrow> a i j < 0\"\n  and \"\\<forall>i. a i 1 + a i 2 + a i 3 > 0\"\n  shows \"x 1 = 0 \\<and> x 2 = 0 \\<and> x 3 = 0\"\n  sorry\n\nend\n"
        },
        "37": {
            "formalization": "theory plumbing_repairs imports Complex_Main\nbegin\n\ntheorem plumbing_repairs:\n  fixes N x :: real\n  assumes \"N + x = 97\" and \"N + 5 * x = 265\"\n  shows \"N + 2 * x = 139\"\n  sorry\n\nend\n"
        },
        "38": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\ntheorem ac_circuits:\n  fixes I :: complex\n  assumes \"V = 1 + i\" and \"Z = 2 - i\"\n  shows \"I = (V / Z) = (1 / 5) + (3 / 5) * i\"\n  using assms by (simp add: field_simps)\n\nend\n"
        },
        "39": {
            "formalization": "theory amc10_2006_p25 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2006_p25:\n  fixes A :: nat\n  assumes \"A = sum_divisors 500\"\n  shows \"sum_distinct_prime_divisors A = 25\"\n  sorry\n\nend\n"
        },
        "40": {
            "formalization": "theory test\nimports Complex_Main\nbegin\n\nfun f :: \"nat ⇒ nat\" where\n  \"f 2 = 0\" |\n  \"f 3 = 1\" |\n  \"f 9999 = 3333\" |\n  \"f (m + n) = f m + f n + (if (f m + f n) mod 2 = 0 then 0 else 1)\"\n\ntheorem f_function_value:\n  shows \"f 1982 = 660\"\n  sorry\n\nend\n"
        },
        "41": {
            "formalization": "theory enrollment_problem imports Complex_Main\nbegin\n\ntheorem enrollment_increase:\n  fixes last_year_enrollment :: real\n  assumes \"last_year_enrollment * 1.04 = 598\"\n  shows \"last_year_enrollment = 575\"\n  sorry\n\nend\n"
        },
        "42": {
            "formalization": "theory test\n  imports Complex_Main\nbegin\n\ntheorem inequality_solution:\n  fixes x :: real\n  assumes \"4 * x^2 / ((1 - sqrt (2 * x + 1))^2) < 2 * x + 9\"\n  shows \"∃x. 4 * x^2 / ((1 - sqrt (2 * x + 1))^2) < 2 * x + 9\"\n  sorry\n\nend\n"
        },
        "43": {
            "formalization": "theory amc12a_2005_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2005_p5:\n  fixes n :: nat\n  assumes \"((2*n)^2 + (2*n + 2)^2 + (2*n + 4)^2) = 12296\"\n  shows \"(2*n) * (2*n + 2) * (2*n + 4) div 8 = 32736\"\n  sorry\n\nend\n"
        },
        "44": {
            "formalization": "theory intersection_lines imports Complex_Main\nbegin\n\ntheorem intersection_lines:\n  fixes s t :: real\n  assumes \"s = 9 - 2 * t\" and \"t = 3 * s + 1\"\n  shows \"(s, t) = (1, 4)\"\n  sorry\n\nend\n"
        },
        "45": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes a b c :: real\n  assumes \"P x = x^3 + a * x^2 + b * x + c\"\n  assumes \"roots P = {cos (2 * pi / 7), cos (4 * pi / 7), cos (6 * pi / 7)}\"\n  shows \"a * b * c = 1 / 32\"\n  sorry\n\nend\n"
        },
        "46": {
            "formalization": "theory complex_eval imports Complex_Main\nbegin\n\ntheorem complex_eval:\n  shows \"((\\<i> / 2) ^ 2) = - (1 / 4)\"\n  sorry\n\nend\n"
        },
        "47": {
            "formalization": "theory mod_computation imports\n  Complex_Main\nbegin\n\ntheorem mod_computation:\n  shows \"29^13 - 5^13 mod 7 = 3\"\n  sorry\n\nend\n"
        },
        "48": {
            "formalization": "theory patio_problem imports Complex_Main\nbegin\n\ntheorem patio_diagonal_squared:\n  fixes l w :: real\n  assumes \"l * w = 180\" and \"2 * (l + w) = 54\"\n  shows \"l^2 + w^2 = 369\"\n  sorry\n\nend\n"
        },
        "49": {
            "formalization": "theory example_problem imports Complex_Main\nbegin\n\ntheorem example_problem:\n  fixes y :: real\n  assumes \"sqrt (19 + 3 * y) = 7\"\n  shows \"y = 10\"\n  sorry\n\nend\n"
        }
    },
    "zero-shot+scir": {
        "0": {
            "formalization": "theory Factorial_Divisibility\n  imports Main \"~~/src/HOL/Number_Theory/Divisibility\"\nbegin\n\nlemma least_positive_integer:\n  assumes \"n > 0\"\n  shows \"80325 divides (fact n) \\<longleftrightarrow> n \\<ge> 17\"\n  using assms\n  by (simp add: factorial_divides_iff)\n\nlemma least_n:\n  shows \"80325 divides (fact 17) \\<and> (\\<forall>n < 17. \\<not> 80325 divides (fact n))\"\n  by (simp add: factorial_divides_iff)\n\nend\n"
        },
        "1": {
            "formalization": "theory Divisibility\n  imports Main\nbegin\n\nlemma div_11: \"∀n::nat. 11 ∣ (10^n - (-1)^n)\"\n  by (induction n) (auto simp add: mod_mult_right mod_add)\n\nend\n"
        },
        "2": {
            "formalization": "theory Congruence\n  imports Main\nbegin\n\nlemma congruence_solution:\n  assumes \"3 * n ≡ 2 (mod 11)\"\n  shows \"n ≡ 8 (mod 11)\"\nproof -\n  have \"3 * 8 mod 11 = 24 mod 11\"\n    by simp\n  also have \"... = 2\"\n    by simp\n  finally show ?thesis\n    by (simp add: assms)\nqed\n\nend\n"
        },
        "3": {
            "formalization": "theory Euler_Prime\n  imports Main\nbegin\n\nfun p :: \"nat ⇒ nat\" where\n  \"p n = n^2 - n + 41\"\n\nlemma common_factor:\n  assumes \"n > 0\"\n  shows \"gcd (p n) (p (n + 1)) > 1 ⟷ n = 41\"\nproof -\n  have \"p (n + 1) = (n + 1)^2 - (n + 1) + 41\"\n    by (simp add: p.simps)\n  have \"p (n + 1) = n^2 + 2n + 1 - n - 1 + 41\"\n    by (simp add: p.simps)\n  then show ?thesis\n    by (simp add: gcd_def)\nqed\n\nend\n"
        },
        "4": {
            "formalization": "theory MinValue\n  imports \"HOL.Real\"\nbegin\n\nlemma min_value:\n  fixes x :: real\n  shows \"x^2 - 14*x + 3 = (x - 7)^2 - 49 + 3\"\n  by (simp add: algebra_simps)\n\nlemma minimum_at_7:\n  shows \"min x. (x^2 - 14*x + 3) = 3\"\n  using min_value by (simp add: real_min_def)\n\nlemma value_at_7:\n  shows \"(7^2 - 14*7 + 3) = 3\"\n  by (simp)\n\nend\n"
        },
        "5": {
            "formalization": "theory Trigonometric_Identity\n  imports Complex_Main\nbegin\n\nlemma sec_tan_csc_cot:\n  assumes \"sec x + tan x = 22 / 7\"\n  shows \"∃m n. csc x + cot x = m / n ∧ coprime m n ∧ m > 0 ∧ n > 0\"\n  using assms\n  by (metis)\n\nend\n"
        },
        "6": {
            "formalization": "theory Integer_Values\n  imports Real\nbegin\n\nlemma integer_values: \"card {x. x ∈ ℤ ∧ |x| < 3 * pi} = 19\"\n  by (simp add: card_of_interval)\n\nend\n"
        },
        "7": {
            "formalization": "theory SumOfRoots\n  imports Main\nbegin\n\nlemma sum_of_roots:\n  assumes \"(x + 3)^2 = 121\"\n  obtains x1 x2 where \"x1 + 3 = 11\" \"x2 + 3 = -11\" \"x1 + x2 = -6\"\n  using assms by auto\n\nend\n"
        },
        "8": {
            "formalization": "theory Expand_Product\n  imports Main\nbegin\n\nlemma expand_product: \"(x + 1)^2 * x = x^3 + 2 * x^2 + x\"\n  by (simp add: power2_eq_square)\n\nend\n"
        },
        "9": {
            "formalization": "theory Prime_Divides\n  imports \"HOL.Number_Theory.Prime\"\nbegin\n\nlemma prime_divides_a_p_minus_a:\n  fixes p :: nat and a :: nat\n  assumes \"prime p\" \"0 < a\"\n  shows \"p dvd (a^p - a)\"\n  using assms\n  by (metis (no_types, lifting) dvd_def prime_dvd_pow)\n\nend\n"
        },
        "10": {
            "formalization": "theory Units_Digit_Sum_Squares\n  imports Main\nbegin\n\nlemma units_digit_sum_squares:\n  shows \"(\\<Sum>n::nat. (n + 1)^2) mod 10 = 5\"\n  unfolding sum.cong\n  by (simp add: sum_of_squares)\n\nend\n"
        },
        "11": {
            "formalization": "theory Distinct_Digits\n  imports Main\nbegin\n\n  definition valid_digit :: \"nat ⇒ bool\" where \"valid_digit d ≡ d ∈ {1, 2, 3, 4, 5, 6, 7, 8, 9}\"\n\n  definition A :: nat where \"A = 1\"\n  definition B :: nat where \"B = 2\"\n  definition C :: nat where \"C = 5\"\n\n  lemma distinct_digits: \"A ≠ B ∧ A ≠ C ∧ B ≠ C ∧ valid_digit A ∧ valid_digit B ∧ valid_digit C\"\n    by (simp add: A_def B_def C_def valid_digit_def)\n\n  lemma equations: \"A + B = C ∧ (10 * A + A) - B = 2 * C ∧ C * B = (10 * A + A) + A\"\n    by (simp add: A_def B_def C_def)\n\n  lemma sum: \"A + B + C = 8\"\n    by (simp add: A_def B_def C_def)\n\nend\n"
        },
        "12": {
            "formalization": "theory Odd_Integers_Product\n  imports Main\nbegin\n\nlemma product_of_odd_integers_less_than_10000:\n  \"(\\<Prod>i::nat. (2*i + 1) | i < 5000) = (10000! / (2^5000 * 5000!))\"\n  by (simp add: factorial_def)\n\nend\n"
        },
        "13": {
            "formalization": "theory SolutionSet\n  imports Real\nbegin\n\nlemma solution_set_integer_count:\n  shows \"card {x :: int. |x - 2| ≤ 5.6} = 11\"\n  by (simp add: abs_le_iff)\n\nend\n"
        },
        "14": {
            "formalization": "theory Triangle_Inequality\n  imports \"HOL.Real\"\nbegin\n\nlemma triangle_inequality:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ≥ 0\"\nproof -\n  (* Proof goes here *)\nqed\n\nlemma equality_condition:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) = 0 ⟷ (a = b ∧ b = c ∧ c = a)\"\n  \nend\n"
        },
        "15": {
            "formalization": "theory Example\n  imports Main\nbegin\n\nlemma example:\n  assumes \"3 * a + b + c = -3\"\n    and \"a + 3 * b + c = 9\"\n    and \"a + b + 3 * c = 19\"\n  shows \"a * b * c = -56\"\nproof -\n  obtain a b c where \"3 * a + b + c = -3\" \"a + 3 * b + c = 9\" \"a + b + 3 * c = 19\"\n    using assms by auto\n  then have \"a = 1\" \"b = -4\" \"c = 3\" by (simp_all add: ...)\n  then show ?thesis by simp\nqed\n\nend\n"
        },
        "16": {
            "formalization": "theory Sequence_Parity\n  imports Main\nbegin\n\nfun D :: \"nat ⇒ nat\" where\n  \"D 0 = 0\" |\n  \"D 1 = 0\" |\n  \"D 2 = 1\" |\n  \"D n = D (n - 1) + D (n - 3) ∀ n ≥ 3\"\n\ndefinition parity :: \"nat ⇒ bool\" where\n  \"parity n ≡ D n mod 2 = 0\"\n\nlemma parity_triple: \"parity 2021 = False ∧ parity 2022 = True ∧ parity 2023 = False\"\n  by (simp add: parity_def)\n\nend\n"
        },
        "17": {
            "formalization": "theory Inverse_Function\n  imports Main\nbegin\n\n  definition h :: \"nat ⇒ nat\" where \"h x = f_inv x\"\n\n  assumption h_2: \"h 2 = 10\"\n  assumption h_10: \"h 10 = 1\"\n  assumption h_1: \"h 1 = 2\"\n\n  lemma f_f_10: \"f (f 10) = 1\"\n  proof -\n    have \"h (f 10) = 2\" using h_1 by (simp add: h_def)\n    then have \"f (h (f 10)) = f 2\" by (simp add: f_inv_def)\n    then show ?thesis using h_2 by (simp add: h_def)\n  qed\n\nend\n"
        },
        "18": {
            "formalization": "theory Perfect_Squares_Divisors\n  imports Main \"HOL/Number_Theory/Divisors\"\nbegin\n\ndefinition factorial_product :: \"nat\" where\n  \"factorial_product = (1! * 2! * 3! * 4! * 5! * 6! * 7! * 8! * 9!)\"\n\nlemma perfect_squares_divisors_count:\n  \"count_perfect_squares_divisors factorial_product = 672\"\n  by (simp add: factorial_product_def)\n\nend\n"
        },
        "19": {
            "formalization": "theory IMO_2001\n  imports Main\nbegin\n\ndefinition I :: nat where \"I = 3\"\ndefinition M :: nat where \"M = 7\"\ndefinition O :: nat where \"O = 95\"\n\nlemma distinct_positive_integers: \"I ≠ M ∧ I ≠ O ∧ M ≠ O\"\n  by (simp add: I_def M_def O_def)\n\nlemma product: \"I * M * O = 2001\"\n  by (simp add: I_def M_def O_def)\n\nlemma sum: \"I + M + O = 3 + 7 + 95\"\n  by (simp add: I_def M_def O_def)\n\nlemma largest_sum: \"I + M + O = 105\"\n  by (simp add: sum)\n\nend\n"
        },
        "20": {
            "formalization": "theory Smallest_X\n  imports Main\nbegin\n\ndefinition X :: nat where\n  \"X = (let m = 3 * (n::nat) + 2 in \n          if m > 0 ∧ (m mod 10 = (4 + 4) mod 10) then m else 0)\"\n\nlemma smallest_X: \"X = 14\"\n  unfolding X_def\n  by (metis mod_eq_0_iff_dvd)\n\nend\n"
        },
        "21": {
            "formalization": "theory Modulo4Remainder\n  imports Main\nbegin\n\nlemma modulo_4_remainder_sum: \"((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12) mod 4) = 2\"\n  by simp\n\nend\n"
        },
        "22": {
            "formalization": "theory Real_Numbers\n  imports \"HOL/Analysis/Real\"\nbegin\n\nlemma real_numbers_bounds:\n  fixes a b c :: real\n  assumes \"a ≤ b\" \"b ≤ c\" \"a + b + c = 2\" \"a * b + b * c + c * a = 1\"\n  shows \"0 ≤ a ∧ a ≤ (1/3) ∧ (1/3) ≤ b ∧ b ≤ 1 ∧ 1 ≤ c ∧ c ≤ (4/3)\"\n  \nend\n"
        },
        "23": {
            "formalization": "theory Percentage_Equation\n  imports Main\nbegin\n\nlemma five_plus_500_percent_of_10_equals_110_percent_of_x:\n  shows \"5 + (500 / 100) * 10 = (110 / 100) * x\" if \"x = 50\"\n  by (simp add: that)\n\nend\n"
        },
        "24": {
            "formalization": "theory Remainder\n  imports \"HOL.Num\"\nbegin\n\nlemma remainder_5_power_999999_mod_7: \"5 ^ 999999 mod 7 = 6\"\n  by (simp add: mod_mult_eq)\n\nend\n"
        },
        "25": {
            "formalization": "theory MaxValue\n  imports Complex_Main\nbegin\n\n  definition f :: \"real ⇒ real\" where\n    \"f t = (2^t - 3*t) * t / 4^t\"\n\n  lemma max_value: \"∃t. f t = 1/12 ∧ ∀x. f x ≤ f t\"\n    by (simp add: f_def)\n\nend\n"
        },
        "26": {
            "formalization": "theory Polynomial_Factorization\n  imports Main\nbegin\n\nlemma factorization_example:\n  assumes \"A * B = 10\" \"A * 3 + B * (-8) = -1\" \"A ∈ ℤ\" \"B ∈ ℤ\"\n  shows \"AB + B = 12\"\n  using assms(1) assms(2) by auto\n\nlemma polynomial_factorization:\n  shows \"∃ A B. A * B = 10 ∧ A * 3 + B * (-8) = -1 ∧ A ∈ ℤ ∧ B ∈ ℤ\"\n  by auto\n\nend\n"
        },
        "27": {
            "formalization": "theory Example\n  imports Main\nbegin\n\ndefinition n :: nat where\n  \"n = 3^17 + 3^10\"\n\nlemma \"11 divides (n + 1)\"\n  unfolding n_def\n  by (simp add: power_add)\n\ndefinition A :: nat where\n  \"A = 1\"  (* Example value, to be replaced with actual distinct digit *)\n\ndefinition B :: nat where\n  \"B = 2\"  (* Example value, to be replaced with actual distinct digit *)\n\ndefinition C :: nat where\n  \"C = 9\"  (* Example value, to be replaced with actual distinct digit *)\n\nlemma distinct_digits: \"A ≠ B ∧ A ≠ C ∧ B ≠ C\"\n  unfolding A_def B_def C_def\n  by auto\n\nlemma odd_conditions: \"odd A ∧ odd C\"\n  unfolding A_def C_def\n  by auto\n\nlemma not_divisible_by_3: \"B mod 3 ≠ 0\"\n  unfolding B_def\n  by auto\n\nlemma find_100A_10B_C: \"100 * A + 10 * B + C = 129\"\n  unfolding A_def B_def C_def\n  by simp\n\nlemma distinct_digit_constraints: \"A < 10 ∧ B < 10 ∧ C < 10\"\n  unfolding A_def B_def C_def\n  by auto\n\nend\n"
        },
        "28": {
            "formalization": "theory Remainder_Example\n  imports Main\nbegin\n\nlemma remainder_54_mod_6: \"54 mod 6 = 0\"\n  by (simp add: mod_eq_0_iff_dvd)\n\nend\n"
        },
        "29": {
            "formalization": "theory Example\n  imports Real\nbegin\n\nlemma example:\n  assumes \"a ∈ ℝ\" \"b ∈ ℝ\" \"a^2 * b^3 = 32 / 27\" \"a / b^3 = 27 / 4\"\n  shows \"a + b = 8 / 3\"\n  using assms\n  by (simp add: field_simps)\n\nend\n"
        },
        "30": {
            "formalization": "theory Sequence_Transformation\n  imports Complex_Main\nbegin\n\n  definition transformation :: \"real × real ⇒ real × real\" where\n    \"transformation (a, b) = (\\<sqrt>3 * a - b, \\<sqrt>3 * b + a)\"\n\n  definition sequence :: \"nat ⇒ real × real\" where\n    \"sequence n = (if n = 100 then (2, 4) else transformation (sequence (n - 1)))\"\n\n  lemma a1_b1_sum: \"fst (sequence 1) + snd (sequence 1) = 1 / 2 ^ 98\"\n    by (simp add: sequence_def transformation_def)\n\nend\n"
        },
        "31": {
            "formalization": "theory Irreducible_Fraction\n  imports Main \"~~/src/HOL/Number_Theory/Divisibility\"\nbegin\n\nlemma irreducible_fraction: \"n ∈ ℕ ⟹ gcd (21 * n + 4) (14 * n + 3) = 1\"\n  by (simp add: gcd.commute)\n\nend\n"
        },
        "32": {
            "formalization": "theory AM_GM\n  imports Real\nbegin\n\nlemma am_gm: \"0 < b ⟹ b ≤ a ⟹ (a + b) / 2 - sqrt (a * b) ≤ (a - b) ^ 2 / (8 * b)\"\n  by (simp add: sqrt_le_iff)\n\nend\n"
        },
        "33": {
            "formalization": "theory LCM_GCD\n  imports Main\nbegin\n\nlemma lcm_gcd_example:\n  assumes \"lcm 120 x = 3720\" and \"gcd 120 x = 8\"\n  shows \"x = 248\"\nproof -\n  have \"lcm 120 x * gcd 120 x = 120 * x\" using lcm_gcd[of 120 x] by auto\n  then have \"3720 * 8 = 120 * x\" using assms by auto\n  then have \"x = (3720 * 8) div 120\" by (simp add: divide_eq_iff)\n  also have \"3720 * 8 = 29760\" by simp\n  then have \"x = 29760 div 120\" by simp\n  also have \"29760 div 120 = 248\" by simp\n  finally show ?thesis by simp\nqed\n\nend\n"
        },
        "34": {
            "formalization": "theory Real_inequality\n  imports \"HOL.Real\"\nbegin\n\nlemma real_inequality: \"∀a b::real. (|a + b|) / (1 + |a + b|) ≤ (|a|) / (1 + |a|) + (|b|) / (1 + |b|)\"\n  by (auto simp: abs_add)\n\nend\n"
        },
        "35": {
            "formalization": "theory Solve_Equation\n  imports Main\nbegin\n\nlemma solve_equation:\n  shows \"x - 9 = 2 * (x + 1) ⟹ x = -11\"\nproof -\n  assume \"x - 9 = 2 * (x + 1)\"\n  have \"x - 9 = 2 * (x + 1)\" using assms by simp\n  then have \"x - 9 = 2 * x + 2\" by simp\n  then have \"x - 2 * x = 9 + 2\" by (simp add: algebra_simps)\n  then have \"-x = 11\" by simp\n  thus ?thesis by simp\nqed\n\nend\n"
        },
        "36": {
            "formalization": "theory System_of_Equations\n  imports Main\nbegin\n\n  definition a11 :: real where \"a11 = 1\"  (* Example positive coefficient *)\n  definition a22 :: real where \"a22 = 1\"  (* Example positive coefficient *)\n  definition a33 :: real where \"a33 = 1\"  (* Example positive coefficient *)\n\n  definition a12 :: real where \"a12 = -1\" (* Example negative coefficient *)\n  definition a13 :: real where \"a13 = -1\" (* Example negative coefficient *)\n  definition a21 :: real where \"a21 = -1\" (* Example negative coefficient *)\n  definition a23 :: real where \"a23 = -1\" (* Example negative coefficient *)\n  definition a31 :: real where \"a31 = -1\" (* Example negative coefficient *)\n  definition a32 :: real where \"a32 = -1\" (* Example negative coefficient *)\n\n  lemma unique_solution:\n    assumes \"a11 > 0\" \"a22 > 0\" \"a33 > 0\"\n    and \"a12 < 0\" \"a13 < 0\" \"a21 < 0\" \"a23 < 0\" \"a31 < 0\" \"a32 < 0\"\n    and \"a11 + a12 + a13 > 0\" \"a21 + a22 + a23 > 0\" \"a31 + a32 + a33 > 0\"\n    shows \"x1 = 0 ∧ x2 = 0 ∧ x3 = 0\"\n  sorry\n\nend\n"
        },
        "37": {
            "formalization": "theory Plumbing_Repair\n  imports Main\nbegin\n\n  definition charge :: \"nat ⇒ nat ⇒ nat\" where\n    \"charge N x = N + x\"\n\n  lemma charge_two_hour_job:\n    assumes \"charge N x = 97\" and \"charge N (5 * x) = 265\"\n    shows \"charge N (2 * x) = 139\"\n  proof -\n    have \"N + x = 97\" using assms(1) by (simp add: charge_def)\n    have \"N + 5 * x = 265\" using assms(2) by (simp add: charge_def)\n    then have \"5 * x = 265 - N\" by (simp add: charge_def)\n    then have \"x = (265 - N) div 5\" by (simp add: div_mult_eq)\n    then have \"N + 2 * x = N + 2 * ((265 - N) div 5)\" by (simp add: charge_def)\n    then have \"N + 2 * x = N + (530 - 2 * N) div 5\" by (simp add: algebra_simps)\n    then show ?thesis by (simp add: charge_def)\n  qed\n\nend\n"
        },
        "38": {
            "formalization": "theory AC_Circuits\n  imports Complex_Main\nbegin\n\nlemma find_current:\n  assumes \"V = 1 + i\"\n  and \"Z = 2 - i\"\n  shows \"I = V / Z\"\n  using assms\n  by (simp add: algebra_simps)\n\nlemma current_value:\n  shows \"I = (1 / 5) + (3 / 5) * i\"\n  using find_current assms(1) assms(2) by (simp add: algebra_simps)\n\nend\n"
        },
        "39": {
            "formalization": "theory Sum_of_Prime_Divisors\n  imports \"HOL/Number_Theory/Divisors\"\nbegin\n\nlemma sum_of_prime_divisors_of_sum_of_divisors_500:\n  shows \"sum_of_prime_divisors (sum_of_divisors 500) = 25\"\n  by (simp add: sum_of_divisors_def)\n\nend\n"
        },
        "40": {
            "formalization": "theory Function_F\n  imports Main\nbegin\n\n  fun f :: \"nat ⇒ nat\" where\n    \"f 2 = 0\" |\n    \"f 3 = Suc 0\" |  (* f(3) > 0 *)\n    \"f 9999 = 3333\" |\n    \"f (m + n) = f m + f n + (if f m + f n < f (m + n) then 1 else 0)\"\n\n  lemma f_1982: \"f 1982 = 660\"\n  proof -\n    (* Proof goes here *)\n  qed\n\nend\n"
        },
        "41": {
            "formalization": "theory Enrollment\n  imports Main\nbegin\n\n  definition last_year_enrollment :: real where\n    \"last_year_enrollment = 598 / (1 + 0.04)\"\n\n  lemma last_year_enrollment_value: \"last_year_enrollment = 575\"\n    by (simp add: last_year_enrollment_def)\n\nend\n"
        },
        "42": {
            "formalization": "theory Inequality_Example\n  imports Main\nbegin\n\nlemma inequality_example:\n  shows \"∀x. (1 - sqrt (2 * x + 1) > 0) ⟶ (4 * x^2 < 2 * x + 9)\"\n  by (simp add: field_simps)\n\nend\n"
        },
        "43": {
            "formalization": "theory Consecutive_Even_Numbers\n  imports Main\nbegin\n\nlemma sum_of_squares_even_numbers:\n  assumes \"x > 0\" and \"even x\"\n  shows \"((x^2) + ((x + 2)^2) + ((x + 4)^2)) = 12296 ⟹ (x * (x + 2) * (x + 4)) div 8 = 32736\"\nproof -\n  have \"x^2 + (x + 2)^2 + (x + 4)^2 = x^2 + (x^2 + 4x + 4) + (x^2 + 8x + 16)\"\n    by simp\n  then have \"3 * x^2 + 12 * x + 20 = 12296\"\n    by simp\n  then have \"3 * x^2 + 12 * x - 12276 = 0\"\n    by simp\n  then have \"x = 38\" \n    using quadratic_formula by auto\n  then have \"x * (x + 2) * (x + 4) = 38 * 40 * 42\"\n    by simp\n  then show ?thesis\n    by (simp add: divide_simps)\nqed\n\nend\n"
        },
        "44": {
            "formalization": "theory Intersection\n  imports Main\nbegin\n\n  definition s :: \"real\" where \"s = 1\"\n  definition t :: \"real\" where \"t = 4\"\n\n  lemma intersection: \"s = 9 - 2 * t ∧ t = 3 * s + 1\"\n  proof -\n    have \"s = 9 - 2 * t\" using s_def t_def by simp\n    have \"t = 3 * s + 1\" using s_def t_def by simp\n    thus ?thesis by (simp add: s_def t_def)\n  qed\n\n  lemma intersection_point: \"(s, t) = (1, 4)\"\n  proof -\n    have \"s = 1\" and \"t = 4\" by (simp add: s_def t_def)\n    thus ?thesis by simp\n  qed\n\nend\n"
        },
        "45": {
            "formalization": "theory PolynomialRoots\n  imports Complex_Main\nbegin\n\nlemma roots_cosine:\n  assumes \"P = (λx. x^3 + a * x^2 + b * x + c)\"\n  shows \"P (cos (2 * π / 7)) = 0 ∧ P (cos (4 * π / 7)) = 0 ∧ P (cos (6 * π / 7)) = 0\"\n  and \"abc = 1 / 32\"\n\nend\n"
        },
        "46": {
            "formalization": "theory Complex_Square\n  imports Complex_Main\nbegin\n\nlemma square_of_i_div_2: \"(\\<frac>i 2) ^ 2 = -\\<frac>1 4\"\n  by (simp add: complex_div_def power2_eq_square)\n\nend\n"
        },
        "47": {
            "formalization": "theory Modulo_Computation\n  imports Main\nbegin\n\nlemma compute_modulo: \"(29^13 - 5^13) mod 7 = 3\"\n  by (simp add: mod_eq_0_iff_dvd)\n\nend\n"
        },
        "48": {
            "formalization": "theory Patio\n  imports Main\nbegin\n\n  definition area :: \"real ⇒ real ⇒ real\" where\n    \"area l w = l * w\"\n\n  definition perimeter :: \"real ⇒ real ⇒ real\" where\n    \"perimeter l w = 2 * (l + w)\"\n\n  lemma diagonal_squared:\n    assumes \"area l w = 180\" and \"perimeter l w = 54\"\n    shows \"l^2 + w^2 = 369\"\n  proof -\n    from assms(1) have \"l * w = 180\" by (simp add: area_def)\n    from assms(2) have \"l + w = 27\" by (simp add: perimeter_def)\n    obtain l w where \"l + w = 27\" and \"l * w = 180\" by (metis assms(1) assms(2) area_def perimeter_def)\n    then have \"l^2 + w^2 = (l + w)^2 - 2 * l * w\" by (metis algebra_simps)\n    then show ?thesis using `l + w = 27` `l * w = 180` by auto\n  qed\n\nend\n"
        },
        "49": {
            "formalization": "theory Example\n  imports Main\nbegin\n\nlemma sqrt_example: \"sqrt (19 + 3 * y) = 7 ⟹ y = 10\"\nproof -\n  assume \"sqrt (19 + 3 * y) = 7\"\n  then have \"19 + 3 * y = 49\" by (simp add: sqrt_eq_iff_sq)\n  then have \"3 * y = 30\" by simp\n  then show \"y = 10\" by simp\nqed\n\nend\n"
        }
    },
    "3-shot+scir": {
        "0": {
            "formalization": "theory amc12a_2009_p4 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2009_p4:\n  fixes n :: nat\n  assumes \"80325 divides n!\"\n  shows \"n = 17\"\n  proof -\n    have \"80325 = 3^4 * 5^2 * 7^1\" by (simp add: power_eq_0_iff)\n    then have \"n! mod 80325 = 0\" if \"n < 17\" for n :: nat\n      using that\n      by (metis factorial_less_0)\n    then show ?thesis\n      using assms by auto\n  qed\n\nend\n"
        },
        "1": {
            "formalization": "theory divisibility_theorem imports\n  Complex_Main\nbegin\n\ntheorem divisibility_by_11:\n  fixes n :: nat\n  shows \"11 dvd (10^n - (-1)^n)\"\n  by (induction n) (auto simp add: algebra_simps)\n\nend\n"
        },
        "2": {
            "formalization": "theory congruence_example imports\n  Complex_Main\nbegin\n\ntheorem congruence_solution:\n  fixes n :: nat\n  assumes \"3 * n mod 11 = 2\"\n  shows \"n mod 11 = 8\"\n  using assms\n  apply (simp add: mod_eq_iff)\n  apply (metis add.commute add.left_neutral mod_add_self2 mod_eq_0_iff_dvd)\n  done\n\nend\n"
        },
        "3": {
            "formalization": "theory euler_polynomial imports Complex_Main\nbegin\n\ntheorem euler_polynomial:\n  fixes n :: nat\n  defines \"p n ≡ n^2 - n + 41\"\n  assumes \"∃ n. gcd (p n) (p (n + 1)) > 1\"\n  shows \"∃ m. m > 0 ∧ m < n ∧ gcd (p m) (p (m + 1)) > 1 ⟹ n = 41\"\n  sorry\n\nend\n"
        },
        "4": {
            "formalization": "theory minimum_value imports Complex_Main\nbegin\n\ntheorem minimum_value:\n  fixes x :: real\n  shows \"x^2 - 14*x + 3 = (x - 7)^2 - 46\"\nproof -\n  have \"x^2 - 14*x + 3 = (x - 7)^2 - 46\" by (simp add: algebra_simps)\n  thus ?thesis by simp\nqed\n\ntheorem minimum_at_seven:\n  shows \"min x. (x^2 - 14*x + 3) = 7\"\n  using minimum_value by auto\n\nend\n"
        },
        "5": {
            "formalization": "theory amc10_2009_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2009_p5:\n  fixes x :: real\n  assumes \"sec x + tan x = 22 / 7\"\n  obtains m n where \"csc x + cot x = m / n\" \"gcd(m, n) = 1\" \"m + n = 44\"\n  sorry\n\nend\n"
        },
        "6": {
            "formalization": "theory integer_values imports Complex_Main\nbegin\n\ntheorem integer_values:\n  fixes x :: real\n  assumes \"abs x < 3 * pi\"\n  shows \"x \\<in> { -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }\"\n  using assms by auto\n\nend\n"
        },
        "7": {
            "formalization": "theory amc12a_2008_p5 imports Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  obtains x1 x2 :: real where \"(x1 + 3)^2 = 121\" \"(x2 + 3)^2 = 121\" \"x1 + x2 = -6\"\nproof -\n  have \"x1 + 3 = 11 ∨ x1 + 3 = -11\" by (simp add: power2_eq_iff)\n  then obtain x1 where \"x1 = 8 ∨ x1 = -12\" by auto\n  then have \"x2 = -6 - x1\" by auto\n  thus ?thesis by (metis)\nqed\n\nend\n"
        },
        "8": {
            "formalization": "theory polynomial_expansion imports Complex_Main\nbegin\n\ntheorem polynomial_expansion:\n  shows \"((x + 1)^2) * x = x^3 + 2 * x^2 + x\"\n  by (simp add: algebra_simps)\n\nend\n"
        },
        "9": {
            "formalization": "theory prime_divides imports\n  Complex_Main\nbegin\n\ntheorem prime_divides:\n  fixes p :: nat and a :: nat\n  assumes \"prime p\" and \"a > 0\"\n  shows \"p dvd (a^p - a)\"\n  using assms\n  apply (rule prime_dvd_binom)\n  apply (simp add: binom_def)\n  done\n\nend\n"
        },
        "10": {
            "formalization": "theory units_digit_sum_of_squares imports\n  Complex_Main\nbegin\n\ntheorem units_digit_sum_of_squares:\n  shows \"(\\<Sum>n=1..9. n^2) mod 10 = 5\"\nproof -\n  have \"(\\<Sum>n=1..9. n^2) = 1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2 + 7^2 + 8^2 + 9^2\"\n    by simp\n  also have \"... = 1 + 4 + 9 + 16 + 25 + 36 + 49 + 64 + 81\"\n    by simp\n  finally have \"(\\<Sum>n=1..9. n^2) = 285\" by simp\n  thus ?thesis by simp\nqed\n\nend\n"
        },
        "11": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes A B C :: nat\n  assumes \"A + B = C\"\n      and \"10 * A + A - B = 2 * C\"\n      and \"C * B = 10 * A + A + A\"\n      and \"A > 0\" and \"B > 0\" and \"C > 0\"\n      and \"A \\<noteq> B\" and \"B \\<noteq> C\" and \"A \\<noteq> C\"\n  shows \"A + B + C = 8\"\n  using assms by auto\n\nend\n"
        },
        "12": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  shows \"(\\<prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\n  proof -\n    have \"(\\<prod>i::nat. (2*i + 1)) = (10000! / (2^5000 * 5000!))\"\n      by (simp add: some_proof)\n    thus ?thesis by simp\n  qed\n\nend\n"
        },
        "13": {
            "formalization": "theory inequality_solution imports Complex_Main\nbegin\n\ntheorem inequality_solution:\n  fixes x :: real\n  assumes \"abs (x - 2) ≤ 5.6\"\n  shows \"card {n :: int. 2 - 5.6 ≤ real n ∧ real n ≤ 2 + 5.6} = 11\"\n  using assms\n  by (auto simp: abs_le_iff)\n\nend\n"
        },
        "14": {
            "formalization": "theory triangle_inequality imports\n  Complex_Main\nbegin\n\ntheorem triangle_inequality:\n  fixes a b c :: real\n  assumes \"a > 0\" \"b > 0\" \"c > 0\"\n  shows \"a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) ≥ 0\"\n  and \"a = b ⟹ b = c ⟹ c = a ⟹ a^2 * b * (a - b) + b^2 * c * (b - c) + c^2 * a * (c - a) = 0\"\n  sorry\n\nend\n"
        },
        "15": {
            "formalization": "theory system_of_equations imports Complex_Main\nbegin\n\ntheorem system_of_equations:\n  fixes a b c :: real\n  assumes \"3*a + b + c = -3\"\n      and \"a + 3*b + c = 9\"\n      and \"a + b + 3*c = 19\"\n  shows \"a * b * c = -56\"\n  using assms(1) assms(2) assms(3) \n  by (simp add: algebra_simps)\n\nend\n"
        },
        "16": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\nfun D :: \"nat \\<Rightarrow> nat\" where\n  \"D 0 = 0\" |\n  \"D 1 = 0\" |\n  \"D 2 = 1\" |\n  \"D n = D (n - 1) + D (n - 3) \\<forall> n \\<ge> 3\"\n\ntheorem amc12a_2008_p5:\n  shows \"D 2021 mod 2 = 0 \\<and> D 2022 mod 2 = 1 \\<and> D 2023 mod 2 = 0\"\n  sorry\n\nend\n"
        },
        "17": {
            "formalization": "theory functional_inverse imports\n  Complex_Main\nbegin\n\ntheorem functional_inverse:\n  fixes f h :: \"real ⇒ real\"\n  assumes \"h = f^-1\"\n  and \"h 2 = 10\"\n  and \"h 10 = 1\"\n  and \"h 1 = 2\"\n  shows \"f (f 10) = 1\"\n  by (metis assms(1) assms(2) assms(3) assms(4) inverse_f_f)\n\nend\n"
        },
        "18": {
            "formalization": "theory amc10_2006_p5 imports\n  Complex_Main\nbegin\n\nfun prod_factorials :: \"nat ⇒ nat\" where\n  \"prod_factorials 0 = 1\" |\n  \"prod_factorials (Suc n) = prod_factorials n * fact (Suc n)\"\n\nfun count_perfect_squares :: \"nat ⇒ nat\" where\n  \"count_perfect_squares 0 = 1\" |\n  \"count_perfect_squares n = (if n mod 2 = 0 then count_perfect_squares (n div 2) + 1 else count_perfect_squares (n - 1))\"\n\ntheorem amc10_2006_p5:\n  fixes n :: nat\n  assumes \"n = 9\"\n  shows \"count_perfect_squares (prod_factorials n) = 672\"\n  using assms\n  by (simp add: prod_factorials.simps count_perfect_squares.simps)\n\nend\n"
        },
        "19": {
            "formalization": "theory amc12a_2001_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2001_p5:\n  fixes I M O :: nat\n  assumes \"I * M * O = 2001\" and \"I \\<noteq> M\" and \"M \\<noteq> O\" and \"I \\<noteq> O\"\n  shows \"I + M + O = 671\"\n  sorry\n\nend\n"
        },
        "20": {
            "formalization": "theory problem_statement imports Complex_Main\nbegin\n\ntheorem smallest_X:\n  fixes X :: nat\n  assumes \"X > 0\" and \"X mod 3 = 2\" and \"X mod 10 = (4 + 5) mod 10\"\n  shows \"X = 14\"\n  sorry\n\nend\n"
        },
        "21": {
            "formalization": "theory sum_modulo_4 imports Complex_Main\nbegin\n\ntheorem sum_modulo_4:\n  shows \"((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12) mod 4) = 2\"\n  by simp\n\nend\n"
        },
        "22": {
            "formalization": "theory imo_1994_p6 imports\n  Complex_Main\nbegin\n\ntheorem imo_1994_p6:\n  fixes a b c :: real\n  assumes \"a ≤ b\" \"b ≤ c\" \"a + b + c = 2\" \"a * b + b * c + c * a = 1\"\n  shows \"0 ≤ a ∧ a ≤ (1/3) ∧ (1/3) ≤ b ∧ b ≤ 1 ∧ 1 ≤ c ∧ c ≤ (4/3)\"\n  sorry\n\nend\n"
        },
        "23": {
            "formalization": "theory amc10_2005_p1 imports\n  Complex_Main\nbegin\n\ntheorem amc10_2005_p1:\n  fixes x :: real\n  assumes \"5 + (500 / 100) * 10 = (110 / 100) * x\"\n  shows \"x = 50\"\n  sorry\n\nend\n"
        },
        "24": {
            "formalization": "theory remainder_power imports\n  Complex_Main\nbegin\n\ntheorem remainder_power:\n  shows \"5^999999 mod 7 = 6\"\n  proof -\n    have \"5 mod 7 = 5\" by simp\n    have \"5^6 mod 7 = 1\" by (simp add: power_mod)\n    have \"999999 mod 6 = 3\" by (simp add: mod_eq_div_iff)\n    have \"5^999999 mod 7 = 5^3 mod 7\" using `999999 mod 6 = 3` by (simp add: power_mod)\n    also have \"... = 125 mod 7\" by (simp add: power_mult)\n    also have \"... = 6\" by simp\n    finally show \"5^999999 mod 7 = 6\" .\n  qed\n\nend\n"
        },
        "25": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes t :: real\n  defines \"f t = (2^t - 3*t) * t / (4^t)\"\n  assumes \"t \\<in> real\"\n  shows \"(\\<exists>t. f t = 1/12) \\<and> (\\<forall>t'. f t' \\<le> 1/12)\"\n  sorry\n\nend\n"
        },
        "26": {
            "formalization": "theory amc10_2006_p1 imports Complex_Main\nbegin\n\ntheorem amc10_2006_p1:\n  fixes A B :: int\n  assumes \"A * B = 10\" and \"A * 3 - 8 * B = -1\"\n  shows \"A * B + B = 12\"\n  using assms by auto\n\nend\n"
        },
        "27": {
            "formalization": "theory aime_1997_p5 imports Complex_Main\nbegin\n\ntheorem aime_1997_p5:\n  fixes A B C :: nat\n  assumes \"n = 3^17 + 3^10\"\n      and \"n + 1 ≡ 0 (mod 11)\"\n      and \"n = 1000000 * A + 100000 * B + 10000 * C + 1000 * A + 100 * C + 10 * C + 1 * B\"\n      and \"A ≠ B\" and \"A ≠ C\" and \"B ≠ C\"\n      and \"A mod 2 = 1\" and \"C mod 2 = 1\"\n      and \"B mod 3 ≠ 0\"\n  shows \"100 * A + 10 * B + C = 129\"\n  sorry\n\nend\n"
        },
        "28": {
            "formalization": "theory mod_example imports Complex_Main\nbegin\n\ntheorem mod_example:\n  shows \"54 mod 6 = 0\"\n  by (simp add: mod_eq_0_iff)\n\nend\n"
        },
        "29": {
            "formalization": "theory aime_1985_p5 imports Complex_Main\nbegin\n\ntheorem aime_1985_p5:\n  fixes a b :: real\n  assumes \"a^2 * b^3 = 32 / 27\" and \"a / b^3 = 27 / 4\"\n  shows \"a + b = 8 / 3\"\n  by (metis assms(1) assms(2) real_divide_eq_iff_eq mult.commute)\n\nend\n"
        },
        "30": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\nfun f :: \"nat ⇒ (real × real) ⇒ (real × real)\" where\n  \"f 0 (a, b) = (a, b)\" |\n  \"f (Suc n) (a, b) = f n (sqrt 3 * a - b, sqrt 3 * b + a)\"\n\ntheorem amc12a_2008_p5:\n  fixes a b :: real\n  assumes \"a = a_1\" and \"b = b_1\"\n  shows \"f 100 (a, b) = (2, 4) ⟹ a + b = 1 / (2 ^ 98)\"\n  sorry\n\nend\n"
        },
        "31": {
            "formalization": "theory irreducible_fraction imports\n  Complex_Main\nbegin\n\ntheorem irreducible_fraction:\n  fixes n :: nat\n  shows \"gcd(21*n + 4, 14*n + 3) = 1\"\n  by (simp add: gcd.commute)\n\nend\n"
        },
        "32": {
            "formalization": "theory am_gm_inequality imports\n  Complex_Main\nbegin\n\ntheorem am_gm_inequality:\n  fixes a b :: real\n  assumes \"a > 0\" \"b > 0\" \"b ≤ a\"\n  shows \"(a + b) / 2 - sqrt (a * b) ≤ (a - b)^2 / (8 * b)\"\n  sorry\n\nend\n"
        },
        "33": {
            "formalization": "theory lcm_gcd imports Complex_Main\nbegin\n\ntheorem lcm_gcd:\n  fixes a b :: nat\n  assumes \"lcm a b = 3720\" and \"gcd a b = 8\" and \"a = 120\"\n  shows \"b = 248\"\n  using assms\n  apply (simp add: lcm_gcd)\n  done\n\nend\n"
        },
        "34": {
            "formalization": "theory inequality\n  imports Complex_Main\nbegin\n\ntheorem inequality:\n  fixes a b :: real\n  shows \"(|a + b|) / (1 + |a + b|) ≤ (|a|) / (1 + |a|) + (|b|) / (1 + |b|)\"\n  sorry\n\nend\n"
        },
        "35": {
            "formalization": "theory solve_equation imports Complex_Main\nbegin\n\ntheorem solve_equation:\n  fixes x :: real\n  assumes \"((x - 9) / (x + 1)) = 2\"\n  shows \"x = -11\"\n  proof -\n    have \"x - 9 = 2 * (x + 1)\" using assms by (simp add: field_simps)\n    then have \"x - 9 = 2 * x + 2\" by simp\n    then have \"x - 2 * x = 11\" by simp\n    then show \"x = -11\" by simp\n  qed\n\nend\n"
        },
        "36": {
            "formalization": "theory imo_1997_p6 imports\n  Complex_Main\nbegin\n\ntheorem imo_1997_p6:\n  fixes a :: \"nat \\<Rightarrow> nat \\<Rightarrow> real\" and x :: \"nat \\<Rightarrow> real\"\n  assumes \"a 1 1 > 0\" and \"a 2 2 > 0\" and \"a 3 3 > 0\"\n  and \"\\<forall>i j. (i \\<noteq> j) \\<longrightarrow> a i j < 0\"\n  and \"\\<forall>i. a i 1 + a i 2 + a i 3 > 0\"\n  shows \"x 1 = 0 \\<and> x 2 = 0 \\<and> x 3 = 0\"\n  sorry\n\nend\n"
        },
        "37": {
            "formalization": "theory plumbing_repairs imports Complex_Main\nbegin\n\ntheorem plumbing_repairs:\n  fixes N x :: real\n  assumes \"N + x = 97\" and \"N + 5 * x = 265\"\n  shows \"N + 2 * x = 139\"\n  using assms by auto\n\nend\n"
        },
        "38": {
            "formalization": "theory ac_circuits imports Complex_Main\nbegin\n\ntheorem ac_circuits:\n  fixes I :: complex\n  assumes \"V = 1 + i\" and \"Z = 2 - i\"\n  shows \"I = V / Z = (1 + i) / (2 - i) = (1/5) + (3/5) * i\"\n  using assms by (simp add: complex_div_def)\n\nend\n"
        },
        "39": {
            "formalization": "theory amc10_2006_p25 imports\n  Complex_Main\n  Number_Theory\nbegin\n\ntheorem amc10_2006_p25:\n  fixes A :: nat\n  assumes \"A = sum_divisors 500\"\n  shows \"sum_distinct_prime_divisors A = 25\"\n  sorry\n\nend\n"
        },
        "40": {
            "formalization": "theory f_function imports Complex_Main\nbegin\n\nfun f :: \"nat ⇒ nat\" where\n  \"f 2 = 0\" |\n  \"f 3 = Suc 0\" |\n  \"f 9999 = 3333\" |\n  \"f (m + n) = f m + f n + (if (f m + f n) mod 2 = 0 then 0 else 1)\"\n\nlemma non_negative: \"∀n. n > 0 ⟹ f n ≥ 0\"\n  by (induction n) (auto)\n\ntheorem f_function_value:\n  shows \"f 1982 = 660\"\n  sorry\n\nend\n"
        },
        "41": {
            "formalization": "theory enrollment_problem imports Complex_Main\nbegin\n\ntheorem enrollment_increase:\n  fixes last_year_enrollment :: real\n  assumes \"last_year_enrollment * 1.04 = 598\"\n  shows \"last_year_enrollment = 575\"\n  using assms by (simp add: field_simps)\n\nend\n"
        },
        "42": {
            "formalization": "theory inequality_problem imports\n  Complex_Main\nbegin\n\ntheorem inequality_solution:\n  fixes x :: real\n  assumes \"4 * x^2 / ((1 - sqrt (2 * x + 1))^2) < 2 * x + 9\"\n  shows \"x ∈ {y. 4 * y^2 / ((1 - sqrt (2 * y + 1))^2) < 2 * y + 9}\"\n  sorry\n\nend\n"
        },
        "43": {
            "formalization": "theory amc12a_2005_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2005_p5:\n  fixes n :: nat\n  assumes \"((2*n)^2 + (2*n + 2)^2 + (2*n + 4)^2) = 12296\"\n  shows \"(2*n) * (2*n + 2) * (2*n + 4) div 8 = 32736\"\n  using assms by auto\n\nend\n"
        },
        "44": {
            "formalization": "theory intersection_lines imports Complex_Main\nbegin\n\ntheorem intersection_lines:\n  fixes s t :: real\n  assumes \"s = 9 - 2 * t\" and \"t = 3 * s + 1\"\n  shows \"(s, t) = (1, 4)\"\n  using assms by auto\n\nend\n"
        },
        "45": {
            "formalization": "theory amc12a_2008_p5 imports\n  Complex_Main\nbegin\n\ntheorem amc12a_2008_p5:\n  fixes a b c :: real\n  assumes \"P x = x^3 + a * x^2 + b * x + c\"\n  assumes \"roots P = {cos (2 * pi / 7), cos (4 * pi / 7), cos (6 * pi / 7)}\"\n  shows \"a * b * c = 1 / 32\"\n  sorry\n\nend\n"
        },
        "46": {
            "formalization": "theory complex_eval imports Complex_Main\nbegin\n\ntheorem complex_eval:\n  shows \"((\\<i> / 2) ^ 2) = - (1 / 4)\"\n  by (simp add: complex_divide_simps)\n\nend\n"
        },
        "47": {
            "formalization": "theory mod_computation imports\n  Complex_Main\nbegin\n\ntheorem mod_computation:\n  shows \"29^13 - 5^13 mod 7 = 3\"\n  by (simp add: mod_eq_0_iff_dvd)\n\nend\n"
        },
        "48": {
            "formalization": "theory patio_problem imports Complex_Main\nbegin\n\ntheorem patio_diagonal_squared:\n  fixes l w :: real\n  assumes \"l * w = 180\" and \"2 * (l + w) = 54\"\n  shows \"l^2 + w^2 = 369\"\n  using assms\n  by (metis (no_types, lifting) add.commute add.right_neutral diff_add_cancel diff_is_0_eq_0 mult.commute mult.left_neutral not_less_eq_eq of_nat_0_le_iff of_nat_add of_nat_mult zero_less_mult_iff)\n\nend\n"
        },
        "49": {
            "formalization": "theory example_problem imports Complex_Main\nbegin\n\ntheorem example_problem:\n  fixes y :: real\n  assumes \"sqrt (19 + 3 * y) = 7\"\n  shows \"y = 10\"\nproof -\n  have \"19 + 3 * y = 49\" using assms by (simp add: sqrt_eq_iff_square)\n  then have \"3 * y = 30\" by simp\n  then show \"y = 10\" by simp\nqed\n\nend\n"
        }
    }
}